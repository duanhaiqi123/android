{"version":3,"file":"adapters/local-execution.mjs","sources":["../../../src/adapters/local-execution.ts"],"sourcesContent":["import type { DeviceAction, ExecutionDump } from '@midscene/core';\nimport { overrideAIConfig } from '@midscene/shared/env';\nimport { uuid } from '@midscene/shared/utils';\nimport { executeAction, parseStructuredParams } from '../common';\nimport type {\n  AgentFactory,\n  ExecutionOptions,\n  FormValue,\n  PlaygroundAgent,\n} from '../types';\nimport { BasePlaygroundAdapter } from './base';\n\nexport class LocalExecutionAdapter extends BasePlaygroundAdapter {\n  private agent: PlaygroundAgent | null;\n  private agentFactory?: AgentFactory; // Factory function for recreating agent\n  private dumpUpdateCallback?: (\n    dump: string,\n    executionDump?: ExecutionDump,\n  ) => void;\n  private progressCallback?: (tip: string) => void;\n  private readonly _id: string; // Unique identifier for this local adapter instance\n  private currentRequestId?: string; // Track current request to prevent stale callbacks\n\n  constructor(agent?: PlaygroundAgent, agentFactory?: AgentFactory) {\n    super();\n    this.agent = agent ?? null;\n    this.agentFactory = agentFactory;\n    this._id = uuid(); // Generate unique ID for local adapter\n  }\n\n  // Get adapter ID\n  get id(): string {\n    return this._id;\n  }\n\n  onDumpUpdate(\n    callback: (dump: string, executionDump?: ExecutionDump) => void,\n  ): void {\n    // Clear any existing callback before setting new one\n    this.dumpUpdateCallback = undefined;\n    // Set the new callback\n    this.dumpUpdateCallback = callback;\n  }\n\n  // Set progress callback for monitoring operation status\n  setProgressCallback(callback: (tip: string) => void): void {\n    this.progressCallback = undefined;\n    this.progressCallback = callback;\n  }\n\n  async parseStructuredParams(\n    action: DeviceAction<unknown>,\n    params: Record<string, unknown>,\n    options: ExecutionOptions,\n  ): Promise<unknown[]> {\n    // Use shared implementation from common.ts\n    return await parseStructuredParams(action, params, options);\n  }\n\n  formatErrorMessage(error: any): string {\n    const errorMessage = error?.message || '';\n    if (errorMessage.includes('of different extension')) {\n      return 'Conflicting extension detected. Please disable the suspicious plugins and refresh the page. Guide: https://midscenejs.com/quick-experience.html#faq';\n    }\n    return this.formatBasicErrorMessage(error);\n  }\n\n  // Local execution - use base implementation\n  // (inherits default executeAction from BasePlaygroundAdapter)\n\n  // Local execution gets actionSpace from internal agent (parameter is for backward compatibility)\n  async getActionSpace(context?: unknown): Promise<DeviceAction<unknown>[]> {\n    // If agent doesn't exist but we have a factory, create one temporarily to get actionSpace\n    if (!this.agent && this.agentFactory) {\n      try {\n        this.agent = await this.agentFactory();\n      } catch (error) {\n        console.warn('Failed to create agent for actionSpace:', error);\n        return [];\n      }\n    }\n\n    // Priority 1: Use agent's getActionSpace method\n    if (this.agent?.getActionSpace) {\n      return await this.agent.getActionSpace();\n    }\n\n    // Priority 2: Use agent's interface.actionSpace method\n    if (\n      this.agent &&\n      'interface' in this.agent &&\n      typeof this.agent.interface === 'object'\n    ) {\n      const page = this.agent.interface as {\n        actionSpace?: () => DeviceAction<unknown>[];\n      };\n      if (page?.actionSpace) {\n        return page.actionSpace();\n      }\n    }\n\n    // Priority 3: Fallback to context parameter (for backward compatibility with tests)\n    if (context && typeof context === 'object' && 'actionSpace' in context) {\n      const contextPage = context as {\n        actionSpace: () => DeviceAction<unknown>[];\n      };\n      return contextPage.actionSpace();\n    }\n\n    return [];\n  }\n\n  // Local execution doesn't use a server, so always return true\n  async checkStatus(): Promise<boolean> {\n    return true;\n  }\n\n  async overrideConfig(aiConfig: Record<string, unknown>): Promise<void> {\n    // For local execution, use the shared env override function\n    overrideAIConfig(aiConfig);\n    console.log('Config updated. Agent will be recreated on next execution.');\n  }\n\n  /**\n   * Safely detaches the Chrome debugger without destroying the agent.\n   * This removes the \"Debugger attached\" banner from the browser window\n   * while keeping the agent instance intact for potential reuse.\n   * Called on errors to improve user experience by cleaning up the UI.\n   */\n  private async detachDebuggerSafely() {\n    try {\n      const page = this.agent?.interface as\n        | { detachDebugger?: () => Promise<void> }\n        | undefined;\n      await page?.detachDebugger?.();\n    } catch (error) {\n      console.warn('Failed to detach debugger:', error);\n    }\n  }\n\n  async executeAction(\n    actionType: string,\n    value: FormValue,\n    options: ExecutionOptions,\n  ): Promise<unknown> {\n    // If agentFactory is provided, always recreate agent with latest config before execution\n    if (this.agentFactory) {\n      if (this.agent) {\n        console.log('Destroying old agent before execution...');\n        try {\n          await this.agent.destroy?.();\n        } catch (error) {\n          console.warn('Failed to destroy old agent:', error);\n        }\n        this.agent = null;\n      }\n\n      // Create new agent with latest config\n      await this.recreateAgent();\n    }\n\n    // Agent must exist (either recreated or provided in constructor)\n    if (!this.agent) {\n      throw new Error(\n        'No agent available. Please provide either an agent instance or agentFactory.',\n      );\n    }\n\n    const agent = this.agent;\n\n    // Get actionSpace using our simplified getActionSpace method\n    const actionSpace = await this.getActionSpace();\n    let removeListener: (() => void) | undefined;\n\n    // Reset dump at the start of execution to ensure clean state\n    try {\n      agent.resetDump?.();\n    } catch (error: unknown) {\n      console.warn('Failed to reset dump before execution:', error);\n    }\n\n    // Setup dump update tracking if requestId is provided\n    if (options.requestId) {\n      // Track current request ID to prevent stale callbacks\n      this.currentRequestId = options.requestId;\n\n      // Add listener and save remove function\n      removeListener = agent.addDumpUpdateListener(\n        (dump: string, executionDump?: ExecutionDump) => {\n          // Only process if this is still the current request\n          if (this.currentRequestId !== options.requestId) {\n            return;\n          }\n\n          // Forward to external callback\n          if (this.dumpUpdateCallback) {\n            this.dumpUpdateCallback(dump, executionDump);\n          }\n        },\n      );\n    }\n\n    try {\n      let result = null;\n      let executionError = null;\n\n      try {\n        // Call the base implementation with the original signature\n        result = await executeAction(\n          agent,\n          actionType,\n          actionSpace,\n          value,\n          options,\n        );\n      } catch (error: unknown) {\n        // Capture error but don't throw yet - we need to get dump/reportHTML first\n        executionError = error;\n      }\n\n      // Always construct response with dump and reportHTML, regardless of success/failure\n      const response = {\n        result,\n        dump: null as unknown,\n        reportHTML: null as string | null,\n        error: executionError\n          ? executionError instanceof Error\n            ? executionError.message\n            : String(executionError)\n          : null,\n      };\n\n      // Get dump data - separate try-catch to ensure dump is retrieved even if reportHTML fails\n      try {\n        if (agent.dumpDataString) {\n          const dumpString = agent.dumpDataString();\n          if (dumpString) {\n            const groupedDump = JSON.parse(dumpString);\n            response.dump = groupedDump.executions?.[0] || null;\n          }\n        }\n      } catch (error: unknown) {\n        console.warn('Failed to get dump from agent:', error);\n      }\n\n      // Try to get reportHTML - may fail in browser environment (fs not available)\n      try {\n        if (agent.reportHTMLString) {\n          response.reportHTML = agent.reportHTMLString() || null;\n        }\n      } catch (error: unknown) {\n        // reportHTMLString may throw in browser environment\n        // This is expected in chrome-extension, continue without reportHTML\n      }\n\n      // Write out action dumps - may also fail in browser environment\n      try {\n        if (agent.writeOutActionDumps) {\n          agent.writeOutActionDumps();\n        }\n      } catch (error: unknown) {\n        // writeOutActionDumps may fail in browser environment\n      }\n\n      // Don't throw the error - return it in response so caller can access dump/reportHTML\n      // The caller (usePlaygroundExecution) will check response.error to determine success\n      return response;\n    } finally {\n      // Remove listener to prevent accumulation\n      if (removeListener) {\n        removeListener();\n      }\n    }\n  }\n\n  /**\n   * Recreate agent instance using the factory function.\n   * Called automatically when executeAction is called.\n   */\n  private async recreateAgent(): Promise<void> {\n    if (!this.agentFactory) {\n      throw new Error(\n        'Cannot recreate agent: factory function not provided. Please provide agentFactory in PlaygroundConfig to enable agent recreation.',\n      );\n    }\n\n    console.log('Creating new agent with latest config...');\n    try {\n      this.agent = await this.agentFactory();\n      console.log('Agent created successfully');\n    } catch (error) {\n      console.error('Failed to create agent:', error);\n      throw error;\n    }\n  }\n\n  // Local execution task cancellation - returns dump and reportHTML before destroying\n  async cancelTask(_requestId: string): Promise<{\n    error?: string;\n    success?: boolean;\n    dump?: ExecutionDump | null;\n    reportHTML?: string | null;\n  }> {\n    if (!this.agent) {\n      return { error: 'No active agent found for this requestId' };\n    }\n\n    // Get execution data BEFORE destroying the agent\n    let dump: ExecutionDump | null = null;\n    let reportHTML: string | null = null;\n\n    // Get dump data separately - don't let reportHTML errors affect dump retrieval\n    // IMPORTANT: Must extract dump BEFORE agent.destroy(), as dump is stored in agent memory\n    try {\n      if (typeof this.agent.dumpDataString === 'function') {\n        const dumpString = this.agent.dumpDataString();\n        if (dumpString) {\n          // dumpDataString() returns GroupedActionDump: { executions: ExecutionDump[] }\n          // In Playground, each \"Run\" creates one execution, so we take executions[0]\n          const groupedDump = JSON.parse(dumpString);\n          dump = groupedDump.executions?.[0] ?? null;\n        }\n      }\n    } catch (error) {\n      console.warn(\n        '[LocalExecutionAdapter] Failed to get dump data before cancel:',\n        error,\n      );\n    }\n\n    // Try to get reportHTML separately - this may fail in browser environment\n    // where fs.readFileSync is not available\n    try {\n      if (typeof this.agent.reportHTMLString === 'function') {\n        const html = this.agent.reportHTMLString();\n        if (\n          html &&\n          typeof html === 'string' &&\n          !html.includes('REPLACE_ME_WITH_REPORT_HTML')\n        ) {\n          reportHTML = html;\n        }\n      }\n    } catch (error) {\n      // reportHTMLString may throw in browser environment (fs not available)\n      // This is expected, just continue with dump data only\n      console.warn(\n        '[LocalExecutionAdapter] reportHTMLString not available in this environment',\n      );\n    }\n\n    try {\n      await this.agent.destroy?.();\n      this.agent = null; // Clear agent reference\n      return { success: true, dump, reportHTML };\n    } catch (error: unknown) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      console.error(\n        `[LocalExecutionAdapter] Failed to cancel agent: ${errorMessage}`,\n      );\n      return { error: `Failed to cancel: ${errorMessage}`, dump, reportHTML };\n    }\n  }\n\n  /**\n   * Get current execution data without resetting\n   * This allows retrieving dump and report when execution is stopped\n   */\n  async getCurrentExecutionData(): Promise<{\n    dump: ExecutionDump | null;\n    reportHTML: string | null;\n  }> {\n    const response = {\n      dump: null as ExecutionDump | null,\n      reportHTML: null as string | null,\n    };\n\n    try {\n      // Get dump data\n      if (this.agent?.dumpDataString) {\n        const dumpString = this.agent.dumpDataString();\n        if (dumpString) {\n          const groupedDump = JSON.parse(dumpString);\n          response.dump = groupedDump.executions?.[0] || null;\n        }\n      }\n\n      // Get report HTML\n      if (this.agent?.reportHTMLString) {\n        response.reportHTML = this.agent.reportHTMLString() || null;\n      }\n    } catch (error: unknown) {\n      console.error('Failed to get current execution data:', error);\n    }\n\n    return response;\n  }\n\n  // Get interface information from the agent\n  async getInterfaceInfo(): Promise<{\n    type: string;\n    description?: string;\n  } | null> {\n    if (!this.agent?.interface) {\n      return null;\n    }\n\n    try {\n      const type = this.agent.interface.interfaceType || 'Unknown';\n      const description = this.agent.interface.describe?.() || undefined;\n\n      return {\n        type,\n        description,\n      };\n    } catch (error: unknown) {\n      console.error('Failed to get interface info:', error);\n      return null;\n    }\n  }\n}\n"],"names":["LocalExecutionAdapter","BasePlaygroundAdapter","callback","undefined","action","params","options","parseStructuredParams","error","errorMessage","context","console","page","contextPage","aiConfig","overrideAIConfig","actionType","value","Error","agent","actionSpace","removeListener","dump","executionDump","result","executionError","executeAction","response","String","dumpString","groupedDump","JSON","_requestId","reportHTML","html","type","description","agentFactory","uuid"],"mappings":"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"}