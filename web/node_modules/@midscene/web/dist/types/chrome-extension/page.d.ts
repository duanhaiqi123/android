import type { ElementTreeNode, Point, Size, UIContext } from '@midscene/core';
import type { AbstractInterface, DeviceAction } from '@midscene/core/device';
import type { ElementInfo } from '@midscene/shared/extractor';
import { type KeyInput, type MouseButton } from '../web-page';
export default class ChromeExtensionProxyPage implements AbstractInterface {
    interfaceType: string;
    forceSameTabNavigation: boolean;
    private viewportSize?;
    private activeTabId;
    private destroyed;
    private isMobileEmulation;
    _continueWhenFailedToAttachDebugger: boolean;
    constructor(forceSameTabNavigation: boolean);
    actionSpace(): DeviceAction[];
    setActiveTabId(tabId: number): Promise<void>;
    getActiveTabId(): Promise<number | null>;
    /**
     * Get a list of current tabs
     * @returns {Promise<Array<{id: number, title: string, url: string}>>}
     */
    getBrowserTabList(): Promise<{
        id: string;
        title: string;
        url: string;
        currentActiveTab: boolean;
    }[]>;
    getTabIdOrConnectToCurrentTab(): Promise<number>;
    /**
     * Ensure debugger is attached to the current tab.
     * Uses lazy attach pattern - only attaches when needed.
     */
    private ensureDebuggerAttached;
    private showMousePointer;
    private hideMousePointer;
    /**
     * Public method to detach debugger without destroying the page instance.
     * Useful for error recovery scenarios where we want to remove the debugger banner
     * without completely destroying the page.
     */
    detachDebugger(tabId?: number): Promise<void>;
    private enableWaterFlowAnimation;
    private disableWaterFlowAnimation;
    /**
     * Send a command to the debugger with automatic attach and retry on detachment.
     * Uses lazy attach pattern - will automatically attach if not already attached.
     */
    private sendCommandToDebugger;
    private getPageContentByCDP;
    evaluateJavaScript(script: string): Promise<any>;
    beforeInvokeAction(): Promise<void>;
    private waitUntilNetworkIdle;
    getElementsInfo(): Promise<ElementInfo[]>;
    getXpathsByPoint(point: Point, isOrderSensitive?: boolean): Promise<any>;
    getElementInfoByXpath(xpath: string): Promise<any>;
    getElementsNodeTree(): Promise<ElementTreeNode<ElementInfo>>;
    getContext(): Promise<UIContext>;
    size(): Promise<Size>;
    screenshotBase64(): Promise<string>;
    url(): Promise<string>;
    navigate(url: string): Promise<void>;
    reload(): Promise<void>;
    goBack(): Promise<void>;
    scrollUntilTop(startingPoint?: Point): Promise<void>;
    scrollUntilBottom(startingPoint?: Point): Promise<void>;
    scrollUntilLeft(startingPoint?: Point): Promise<void>;
    scrollUntilRight(startingPoint?: Point): Promise<void>;
    scrollUp(distance?: number, startingPoint?: Point): Promise<void>;
    scrollDown(distance?: number, startingPoint?: Point): Promise<void>;
    scrollLeft(distance?: number, startingPoint?: Point): Promise<void>;
    scrollRight(distance?: number, startingPoint?: Point): Promise<void>;
    clearInput(element: ElementInfo): Promise<void>;
    private latestMouseX;
    private latestMouseY;
    mouse: {
        click: (x: number, y: number, options?: {
            button?: MouseButton;
            count?: number;
        }) => Promise<void>;
        wheel: (deltaX: number, deltaY: number, startX?: number, startY?: number) => Promise<void>;
        move: (x: number, y: number) => Promise<void>;
        drag: (from: {
            x: number;
            y: number;
        }, to: {
            x: number;
            y: number;
        }) => Promise<void>;
    };
    keyboard: {
        type: (text: string) => Promise<void>;
        press: (action: {
            key: KeyInput;
            command?: string;
        } | {
            key: KeyInput;
            command?: string;
        }[]) => Promise<void>;
    };
    destroy(): Promise<void>;
    longPress(x: number, y: number, duration?: number): Promise<void>;
    swipe(from: {
        x: number;
        y: number;
    }, to: {
        x: number;
        y: number;
    }, duration?: number): Promise<void>;
}
