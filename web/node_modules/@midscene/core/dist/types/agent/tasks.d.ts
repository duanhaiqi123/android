import type { TMultimodalPrompt, TUserPrompt } from '../common';
import type { AbstractInterface } from '../device';
import type Service from '../service';
import type { TaskRunner } from '../task-runner';
import { TaskExecutionError } from '../task-runner';
import type { DeepThinkOption, DeviceAction, ExecutionTaskApply, ExecutionTaskProgressOptions, MidsceneYamlFlowItem, PlanningAction, PlanningActionParamSleep, PlanningActionParamWaitFor, ServiceExtractOption, ServiceExtractParam } from '../types';
import type { IModelConfig } from '@midscene/shared/env';
import type { TaskCache } from './task-cache';
export { locatePlanForLocate } from './task-builder';
interface ExecutionResult<OutputType = any> {
    output: OutputType;
    thought?: string;
    runner: TaskRunner;
}
interface TaskExecutorHooks {
    onTaskUpdate?: (runner: TaskRunner, error?: TaskExecutionError) => Promise<void> | void;
}
export { TaskExecutionError };
export declare class TaskExecutor {
    interface: AbstractInterface;
    service: Service;
    taskCache?: TaskCache;
    private readonly providedActionSpace;
    private readonly taskBuilder;
    private conversationHistory;
    onTaskStartCallback?: ExecutionTaskProgressOptions['onTaskStart'];
    private readonly hooks?;
    replanningCycleLimit?: number;
    get page(): AbstractInterface;
    constructor(interfaceInstance: AbstractInterface, service: Service, opts: {
        taskCache?: TaskCache;
        onTaskStart?: ExecutionTaskProgressOptions['onTaskStart'];
        replanningCycleLimit?: number;
        hooks?: TaskExecutorHooks;
        actionSpace: DeviceAction[];
    });
    private createExecutionSession;
    private getActionSpace;
    convertPlanToExecutable(plans: PlanningAction[], modelConfigForPlanning: IModelConfig, modelConfigForDefaultIntent: IModelConfig, options?: {
        cacheable?: boolean;
        subTask?: boolean;
    }): Promise<{
        tasks: ExecutionTaskApply[];
    }>;
    loadYamlFlowAsPlanning(userInstruction: string, yamlString: string): Promise<{
        runner: TaskRunner;
    }>;
    runPlans(title: string, plans: PlanningAction[], modelConfigForPlanning: IModelConfig, modelConfigForDefaultIntent: IModelConfig): Promise<ExecutionResult>;
    action(userPrompt: string, modelConfigForPlanning: IModelConfig, modelConfigForDefaultIntent: IModelConfig, includeBboxInPlanning: boolean, aiActContext?: string, cacheable?: boolean, replanningCycleLimitOverride?: number, imagesIncludeCount?: number, deepThink?: DeepThinkOption, fileChooserAccept?: string[]): Promise<ExecutionResult<{
        yamlFlow?: MidsceneYamlFlowItem[];
    } | undefined>>;
    private runAction;
    private createTypeQueryTask;
    createTypeQueryExecution<T>(type: 'Query' | 'Boolean' | 'Number' | 'String' | 'Assert', demand: ServiceExtractParam, modelConfig: IModelConfig, opt?: ServiceExtractOption, multimodalPrompt?: TMultimodalPrompt): Promise<ExecutionResult<T>>;
    private sleepPlan;
    taskForSleep(timeMs: number, _modelConfig: IModelConfig): Promise<import("../types").ExecutionTaskActionApply<PlanningActionParamSleep>>;
    waitFor(assertion: TUserPrompt, opt: PlanningActionParamWaitFor, modelConfig: IModelConfig): Promise<ExecutionResult<void>>;
}
export declare function withFileChooser<T>(interfaceInstance: AbstractInterface, fileChooserAccept: string[] | undefined, action: () => Promise<T>): Promise<T>;
