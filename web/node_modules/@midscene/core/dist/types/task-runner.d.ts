import type { ExecutionDump, ExecutionTask, ExecutionTaskApply, ExecutionTaskProgressOptions, UIContext } from './types';
type TaskRunnerInitOptions = ExecutionTaskProgressOptions & {
    tasks?: ExecutionTaskApply[];
    onTaskUpdate?: (runner: TaskRunner, error?: TaskExecutionError) => Promise<void> | void;
};
type TaskRunnerOperationOptions = {
    allowWhenError?: boolean;
};
export declare class TaskRunner {
    name: string;
    tasks: ExecutionTask[];
    status: 'init' | 'pending' | 'running' | 'completed' | 'error';
    onTaskStart?: ExecutionTaskProgressOptions['onTaskStart'];
    private readonly uiContextBuilder;
    private readonly onTaskUpdate?;
    constructor(name: string, uiContextBuilder: () => Promise<UIContext>, options?: TaskRunnerInitOptions);
    private emitOnTaskUpdate;
    private lastUiContext?;
    private getUiContext;
    private captureScreenshot;
    private attachRecorderItem;
    private markTaskAsPending;
    private normalizeStatusFromError;
    private findPreviousNonSubTaskUIContext;
    append(task: ExecutionTaskApply[] | ExecutionTaskApply, options?: TaskRunnerOperationOptions): Promise<void>;
    appendAndFlush(task: ExecutionTaskApply[] | ExecutionTaskApply, options?: TaskRunnerOperationOptions): Promise<{
        output: any;
        thought?: string;
    } | undefined>;
    flush(options?: TaskRunnerOperationOptions): Promise<{
        output: any;
        thought?: string;
    } | undefined>;
    isInErrorState(): boolean;
    latestErrorTask(): ExecutionTask | null;
    dump(): ExecutionDump;
    appendErrorPlan(errorMsg: string): Promise<{
        output: undefined;
        runner: TaskRunner;
    }>;
}
export declare class TaskExecutionError extends Error {
    runner: TaskRunner;
    errorTask: ExecutionTask | null;
    constructor(message: string, runner: TaskRunner, errorTask: ExecutionTask | null, options?: {
        cause?: unknown;
    });
}
export {};
