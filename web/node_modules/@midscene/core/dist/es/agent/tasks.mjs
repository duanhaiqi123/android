import { ConversationHistory, plan, uiTarsPlanning } from "../ai-model/index.mjs";
import { TaskExecutionError } from "../task-runner.mjs";
import { ServiceError } from "../types.mjs";
import { getDebug } from "@midscene/shared/logger";
import { assert } from "@midscene/shared/utils";
import { ExecutionSession } from "./execution-session.mjs";
import { TaskBuilder, locatePlanForLocate } from "./task-builder.mjs";
import { descriptionOfTree } from "@midscene/shared/extractor";
import { taskTitleStr } from "./ui-utils.mjs";
import { parsePrompt } from "./utils.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const debug = getDebug('device-task-executor');
const maxErrorCountAllowedInOnePlanningLoop = 5;
class TaskExecutor {
    get page() {
        return this.interface;
    }
    createExecutionSession(title, options) {
        return new ExecutionSession(title, ()=>Promise.resolve(this.service.contextRetrieverFn()), {
            onTaskStart: this.onTaskStartCallback,
            tasks: options?.tasks,
            onTaskUpdate: this.hooks?.onTaskUpdate
        });
    }
    getActionSpace() {
        return this.providedActionSpace;
    }
    async convertPlanToExecutable(plans, modelConfigForPlanning, modelConfigForDefaultIntent, options) {
        return this.taskBuilder.build(plans, modelConfigForPlanning, modelConfigForDefaultIntent, options);
    }
    async loadYamlFlowAsPlanning(userInstruction, yamlString) {
        const session = this.createExecutionSession(taskTitleStr('Action', userInstruction));
        const task = {
            type: 'Planning',
            subType: 'LoadYaml',
            param: {
                userInstruction
            },
            executor: async (param, executorContext)=>{
                const { uiContext } = executorContext;
                assert(uiContext, 'uiContext is required for Planning task');
                return {
                    output: {
                        actions: [],
                        more_actions_needed_by_instruction: false,
                        log: '',
                        yamlString
                    },
                    cache: {
                        hit: true
                    },
                    hitBy: {
                        from: 'Cache',
                        context: {
                            yamlString
                        }
                    }
                };
            }
        };
        const runner = session.getRunner();
        await session.appendAndRun(task);
        return {
            runner
        };
    }
    async runPlans(title, plans, modelConfigForPlanning, modelConfigForDefaultIntent) {
        const session = this.createExecutionSession(title);
        const { tasks } = await this.convertPlanToExecutable(plans, modelConfigForPlanning, modelConfigForDefaultIntent);
        const runner = session.getRunner();
        const result = await session.appendAndRun(tasks);
        const { output } = result ?? {};
        return {
            output,
            runner
        };
    }
    async action(userPrompt, modelConfigForPlanning, modelConfigForDefaultIntent, includeBboxInPlanning, aiActContext, cacheable, replanningCycleLimitOverride, imagesIncludeCount, deepThink, fileChooserAccept) {
        return withFileChooser(this.interface, fileChooserAccept, async ()=>this.runAction(userPrompt, modelConfigForPlanning, modelConfigForDefaultIntent, includeBboxInPlanning, aiActContext, cacheable, replanningCycleLimitOverride, imagesIncludeCount, deepThink));
    }
    async runAction(userPrompt, modelConfigForPlanning, modelConfigForDefaultIntent, includeBboxInPlanning, aiActContext, cacheable, replanningCycleLimitOverride, imagesIncludeCount, deepThink) {
        this.conversationHistory.reset();
        const session = this.createExecutionSession(taskTitleStr('Action', userPrompt));
        const runner = session.getRunner();
        let replanCount = 0;
        const yamlFlow = [];
        const replanningCycleLimit = replanningCycleLimitOverride ?? this.replanningCycleLimit;
        assert(void 0 !== replanningCycleLimit, 'replanningCycleLimit is required for TaskExecutor.action');
        let errorCountInOnePlanningLoop = 0;
        while(true){
            const result = await session.appendAndRun({
                type: 'Planning',
                subType: 'Plan',
                param: {
                    userInstruction: userPrompt,
                    aiActContext,
                    imagesIncludeCount,
                    deepThink
                },
                executor: async (param, executorContext)=>{
                    const startTime = Date.now();
                    const { uiContext } = executorContext;
                    assert(uiContext, 'uiContext is required for Planning task');
                    const { vlMode } = modelConfigForPlanning;
                    const uiTarsModelVersion = 'vlm-ui-tars' === vlMode ? modelConfigForPlanning.uiTarsModelVersion : void 0;
                    const actionSpace = this.getActionSpace();
                    debug('actionSpace for this interface is:', actionSpace.map((action)=>action.name).join(', '));
                    assert(Array.isArray(actionSpace), 'actionSpace must be an array');
                    if (0 === actionSpace.length) console.warn(`ActionSpace for ${this.interface.interfaceType} is empty. This may lead to unexpected behavior.`);
                    const planResult = await (uiTarsModelVersion ? uiTarsPlanning : plan)(param.userInstruction, {
                        context: uiContext,
                        actionContext: param.aiActContext,
                        interfaceType: this.interface.interfaceType,
                        actionSpace,
                        modelConfig: modelConfigForPlanning,
                        conversationHistory: this.conversationHistory,
                        includeBbox: includeBboxInPlanning,
                        imagesIncludeCount,
                        deepThink
                    });
                    debug('planResult', JSON.stringify(planResult, null, 2));
                    const { actions, log, more_actions_needed_by_instruction, error, usage, rawResponse, sleep, reasoning_content } = planResult;
                    executorContext.task.log = {
                        ...executorContext.task.log || {},
                        rawResponse
                    };
                    executorContext.task.usage = usage;
                    executorContext.task.reasoning_content = reasoning_content;
                    executorContext.task.output = {
                        actions: actions || [],
                        more_actions_needed_by_instruction,
                        log,
                        yamlFlow: planResult.yamlFlow
                    };
                    executorContext.uiContext = uiContext;
                    const finalActions = [
                        ...actions || []
                    ];
                    if (sleep) {
                        const timeNow = Date.now();
                        const timeRemaining = sleep - (timeNow - startTime);
                        if (timeRemaining > 0) finalActions.push(this.sleepPlan(timeRemaining));
                    }
                    assert(!error, `Failed to continue: ${error}\n${log || ''}`);
                    return {
                        cache: {
                            hit: false
                        }
                    };
                }
            }, {
                allowWhenError: true
            });
            const planResult = result?.output;
            const plans = planResult?.actions || [];
            yamlFlow.push(...planResult?.yamlFlow || []);
            let executables;
            try {
                executables = await this.convertPlanToExecutable(plans, modelConfigForPlanning, modelConfigForDefaultIntent, {
                    cacheable,
                    subTask: true
                });
            } catch (error) {
                return session.appendErrorPlan(`Error converting plans to executable tasks: ${error}, plans: ${JSON.stringify(plans)}`);
            }
            if (this.conversationHistory.pendingFeedbackMessage) console.warn('unconsumed pending feedback message detected, this may lead to unexpected planning result:', this.conversationHistory.pendingFeedbackMessage);
            let errorFlag = false;
            try {
                await session.appendAndRun(executables.tasks);
            } catch (error) {
                errorFlag = true;
                errorCountInOnePlanningLoop++;
                this.conversationHistory.pendingFeedbackMessage = `Error executing running tasks: ${error?.message || String(error)}`;
                debug('error when executing running tasks, but continue to run if it is not too many errors:', error instanceof Error ? error.message : String(error), 'current error count in one planning loop:', errorCountInOnePlanningLoop);
            }
            if (errorCountInOnePlanningLoop > maxErrorCountAllowedInOnePlanningLoop) return session.appendErrorPlan('Too many errors in one planning loop');
            if (!planResult?.more_actions_needed_by_instruction) if (errorFlag) debug('more_actions_needed_by_instruction is false, but there are errors in one planning loop, continue to run');
            else break;
            ++replanCount;
            if (replanCount > replanningCycleLimit) {
                const errorMsg = `Replanned ${replanningCycleLimit} times, exceeding the limit. Please configure a larger value for replanningCycleLimit (or use MIDSCENE_REPLANNING_CYCLE_LIMIT) to handle more complex tasks.`;
                return session.appendErrorPlan(errorMsg);
            }
            if (!this.conversationHistory.pendingFeedbackMessage) this.conversationHistory.pendingFeedbackMessage = 'I have finished the action previously planned.';
        }
        return {
            output: {
                yamlFlow
            },
            runner
        };
    }
    createTypeQueryTask(type, demand, modelConfig, opt, multimodalPrompt) {
        const queryTask = {
            type: 'Insight',
            subType: type,
            param: {
                dataDemand: multimodalPrompt ? {
                    demand,
                    multimodalPrompt
                } : demand
            },
            executor: async (param, taskContext)=>{
                const { task } = taskContext;
                let queryDump;
                const applyDump = (dump)=>{
                    queryDump = dump;
                    task.log = {
                        dump
                    };
                };
                const uiContext = taskContext.uiContext;
                assert(uiContext, 'uiContext is required for Query task');
                const ifTypeRestricted = 'Query' !== type;
                let demandInput = demand;
                let keyOfResult = 'result';
                if (ifTypeRestricted && ('Assert' === type || 'WaitFor' === type)) {
                    keyOfResult = 'StatementIsTruthy';
                    const booleanPrompt = 'Assert' === type ? `Boolean, whether the following statement is true: ${demand}` : `Boolean, the user wants to do some 'wait for' operation, please check whether the following statement is true: ${demand}`;
                    demandInput = {
                        [keyOfResult]: booleanPrompt
                    };
                } else if (ifTypeRestricted) demandInput = {
                    [keyOfResult]: `${type}, ${demand}`
                };
                let extractResult;
                let extraPageDescription = '';
                if (opt?.domIncluded && this.interface.getElementsNodeTree) {
                    debug('appending tree info for page');
                    const tree = await this.interface.getElementsNodeTree();
                    extraPageDescription = await descriptionOfTree(tree, 200, false, opt?.domIncluded === 'visible-only');
                }
                try {
                    extractResult = await this.service.extract(demandInput, modelConfig, opt, extraPageDescription, multimodalPrompt);
                } catch (error) {
                    if (error instanceof ServiceError) applyDump(error.dump);
                    throw error;
                }
                const { data, usage, thought, dump, reasoning_content } = extractResult;
                applyDump(dump);
                task.reasoning_content = reasoning_content;
                let outputResult = data;
                if (ifTypeRestricted) if ('string' == typeof data) outputResult = data;
                else if ('WaitFor' === type) outputResult = null == data ? false : data[keyOfResult];
                else if (null == data) outputResult = null;
                else {
                    assert(data?.[keyOfResult] !== void 0, 'No result in query data');
                    outputResult = data[keyOfResult];
                }
                if ('Assert' === type && !outputResult) {
                    task.usage = usage;
                    task.thought = thought;
                    throw new Error(`Assertion failed: ${thought}`);
                }
                return {
                    output: outputResult,
                    log: queryDump,
                    usage,
                    thought
                };
            }
        };
        return queryTask;
    }
    async createTypeQueryExecution(type, demand, modelConfig, opt, multimodalPrompt) {
        const session = this.createExecutionSession(taskTitleStr(type, 'string' == typeof demand ? demand : JSON.stringify(demand)));
        const queryTask = await this.createTypeQueryTask(type, demand, modelConfig, opt, multimodalPrompt);
        const runner = session.getRunner();
        const result = await session.appendAndRun(queryTask);
        if (!result) throw new Error('result of taskExecutor.flush() is undefined in function createTypeQueryTask');
        const { output, thought } = result;
        return {
            output,
            thought,
            runner
        };
    }
    sleepPlan(timeMs) {
        return {
            type: 'Sleep',
            param: {
                timeMs
            }
        };
    }
    async taskForSleep(timeMs, _modelConfig) {
        return this.taskBuilder.createSleepTask({
            timeMs
        });
    }
    async waitFor(assertion, opt, modelConfig) {
        const { textPrompt, multimodalPrompt } = parsePrompt(assertion);
        const description = `waitFor: ${textPrompt}`;
        const session = this.createExecutionSession(taskTitleStr('WaitFor', description));
        const runner = session.getRunner();
        const { timeoutMs, checkIntervalMs } = opt;
        assert(assertion, 'No assertion for waitFor');
        assert(timeoutMs, 'No timeoutMs for waitFor');
        assert(checkIntervalMs, 'No checkIntervalMs for waitFor');
        assert(checkIntervalMs <= timeoutMs, `wrong config for waitFor: checkIntervalMs must be less than timeoutMs, config: {checkIntervalMs: ${checkIntervalMs}, timeoutMs: ${timeoutMs}}`);
        const overallStartTime = Date.now();
        let lastCheckStart = overallStartTime;
        let errorThought = '';
        while(lastCheckStart - overallStartTime <= timeoutMs){
            const currentCheckStart = Date.now();
            lastCheckStart = currentCheckStart;
            const queryTask = await this.createTypeQueryTask('WaitFor', textPrompt, modelConfig, void 0, multimodalPrompt);
            const result = await session.appendAndRun(queryTask);
            if (result?.output) return {
                output: void 0,
                runner
            };
            errorThought = result?.thought || !result && `No result from assertion: ${textPrompt}` || `unknown error when waiting for assertion: ${textPrompt}`;
            const now = Date.now();
            if (now - currentCheckStart < checkIntervalMs) {
                const timeRemaining = checkIntervalMs - (now - currentCheckStart);
                const sleepTask = this.taskBuilder.createSleepTask({
                    timeMs: timeRemaining
                });
                await session.append(sleepTask);
            }
        }
        return session.appendErrorPlan(`waitFor timeout: ${errorThought}`);
    }
    constructor(interfaceInstance, service, opts){
        _define_property(this, "interface", void 0);
        _define_property(this, "service", void 0);
        _define_property(this, "taskCache", void 0);
        _define_property(this, "providedActionSpace", void 0);
        _define_property(this, "taskBuilder", void 0);
        _define_property(this, "conversationHistory", void 0);
        _define_property(this, "onTaskStartCallback", void 0);
        _define_property(this, "hooks", void 0);
        _define_property(this, "replanningCycleLimit", void 0);
        this.interface = interfaceInstance;
        this.service = service;
        this.taskCache = opts.taskCache;
        this.onTaskStartCallback = opts?.onTaskStart;
        this.replanningCycleLimit = opts.replanningCycleLimit;
        this.hooks = opts.hooks;
        this.conversationHistory = new ConversationHistory();
        this.providedActionSpace = opts.actionSpace;
        this.taskBuilder = new TaskBuilder({
            interfaceInstance,
            service,
            taskCache: opts.taskCache,
            actionSpace: this.getActionSpace()
        });
    }
}
async function withFileChooser(interfaceInstance, fileChooserAccept, action) {
    if (!fileChooserAccept?.length) return action();
    if (!interfaceInstance.registerFileChooserListener) throw new Error(`File upload is not supported on ${interfaceInstance.interfaceType}`);
    const handler = async (chooser)=>{
        await chooser.accept(fileChooserAccept);
    };
    const { dispose, getError } = await interfaceInstance.registerFileChooserListener(handler);
    try {
        const result = await action();
        const error = getError();
        if (error) throw error;
        return result;
    } finally{
        dispose();
    }
}
export { TaskExecutionError, TaskExecutor, locatePlanForLocate, withFileChooser };

//# sourceMappingURL=tasks.mjs.map