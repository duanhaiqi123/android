import { AiExtractElementInfo, AiLocateElement, callAIWithObjectResponse } from "../ai-model/index.mjs";
import { AiLocateSection } from "../ai-model/inspect.mjs";
import { elementDescriberInstruction } from "../ai-model/prompt/describe.mjs";
import { expandSearchArea } from "../common.mjs";
import { ServiceError } from "../types.mjs";
import { MIDSCENE_FORCE_DEEP_THINK, globalConfigManager } from "@midscene/shared/env";
import { compositeElementInfoImg, cropByRect } from "@midscene/shared/img";
import { getDebug } from "@midscene/shared/logger";
import { assert } from "@midscene/shared/utils";
import { createServiceDump } from "./utils.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const debug = getDebug('ai:service');
class Service {
    async locate(query, opt, modelConfig) {
        const queryPrompt = 'string' == typeof query ? query : query.prompt;
        assert(queryPrompt, 'query is required for locate');
        assert('object' == typeof query, 'query should be an object for locate');
        const globalDeepThinkSwitch = globalConfigManager.getEnvConfigInBoolean(MIDSCENE_FORCE_DEEP_THINK);
        if (globalDeepThinkSwitch) debug('globalDeepThinkSwitch', globalDeepThinkSwitch);
        let searchAreaPrompt;
        if (query.deepThink || globalDeepThinkSwitch) searchAreaPrompt = query.prompt;
        const { vlMode } = modelConfig;
        if (searchAreaPrompt && !vlMode) {
            console.warn('The "deepThink" feature is not supported with multimodal LLM. Please config VL model for Midscene. https://midscenejs.com/model-config');
            searchAreaPrompt = void 0;
        }
        const context = opt?.context || await this.contextRetrieverFn();
        let searchArea;
        let searchAreaRawResponse;
        let searchAreaUsage;
        let searchAreaResponse;
        if (searchAreaPrompt) {
            searchAreaResponse = await AiLocateSection({
                context,
                sectionDescription: searchAreaPrompt,
                modelConfig
            });
            assert(searchAreaResponse.rect, `cannot find search area for "${searchAreaPrompt}"${searchAreaResponse.error ? `: ${searchAreaResponse.error}` : ''}`);
            searchAreaRawResponse = searchAreaResponse.rawResponse;
            searchAreaUsage = searchAreaResponse.usage;
            searchArea = searchAreaResponse.rect;
        }
        const startTime = Date.now();
        const { parseResult, rect, rawResponse, usage, reasoning_content } = await AiLocateElement({
            callAIFn: this.aiVendorFn,
            context,
            targetElementDescription: queryPrompt,
            searchConfig: searchAreaResponse,
            modelConfig
        });
        const timeCost = Date.now() - startTime;
        const taskInfo = {
            ...this.taskInfo ? this.taskInfo : {},
            durationMs: timeCost,
            rawResponse: JSON.stringify(rawResponse),
            formatResponse: JSON.stringify(parseResult),
            usage,
            searchArea,
            searchAreaRawResponse,
            searchAreaUsage,
            reasoning_content
        };
        let errorLog;
        if (parseResult.errors?.length) errorLog = `failed to locate element: \n${parseResult.errors.join('\n')}`;
        const dumpData = {
            type: 'locate',
            userQuery: {
                element: queryPrompt
            },
            matchedElement: [],
            matchedRect: rect,
            data: null,
            taskInfo,
            deepThink: !!searchArea,
            error: errorLog
        };
        const elements = parseResult.elements || [];
        const dump = createServiceDump({
            ...dumpData,
            matchedElement: elements
        });
        if (errorLog) throw new ServiceError(errorLog, dump);
        if (elements.length > 1) throw new ServiceError(`locate: multiple elements found, length = ${elements.length}`, dump);
        if (1 === elements.length) return {
            element: {
                center: elements[0].center,
                rect: elements[0].rect,
                description: elements[0].description
            },
            rect,
            dump
        };
        return {
            element: null,
            rect,
            dump
        };
    }
    async extract(dataDemand, modelConfig, opt, pageDescription, multimodalPrompt) {
        assert('object' == typeof dataDemand || 'string' == typeof dataDemand, `dataDemand should be object or string, but get ${typeof dataDemand}`);
        const context = await this.contextRetrieverFn();
        const startTime = Date.now();
        const { parseResult, usage, reasoning_content } = await AiExtractElementInfo({
            context,
            dataQuery: dataDemand,
            multimodalPrompt,
            extractOption: opt,
            modelConfig,
            pageDescription
        });
        const timeCost = Date.now() - startTime;
        const taskInfo = {
            ...this.taskInfo ? this.taskInfo : {},
            durationMs: timeCost,
            rawResponse: JSON.stringify(parseResult),
            reasoning_content
        };
        let errorLog;
        if (parseResult.errors?.length) errorLog = `AI response error: \n${parseResult.errors.join('\n')}`;
        const dumpData = {
            type: 'extract',
            userQuery: {
                dataDemand
            },
            matchedElement: [],
            data: null,
            taskInfo,
            error: errorLog
        };
        const { data, thought } = parseResult || {};
        const dump = createServiceDump({
            ...dumpData,
            data
        });
        if (errorLog && !data) throw new ServiceError(errorLog, dump);
        return {
            data,
            thought,
            usage,
            reasoning_content,
            dump
        };
    }
    async describe(target, modelConfig, opt) {
        assert(target, 'target is required for service.describe');
        const context = await this.contextRetrieverFn();
        const { screenshotBase64, size } = context;
        assert(screenshotBase64, 'screenshot is required for service.describe');
        const { vlMode } = modelConfig;
        const systemPrompt = elementDescriberInstruction();
        const defaultRectSize = 30;
        const targetRect = Array.isArray(target) ? {
            left: Math.floor(target[0] - defaultRectSize / 2),
            top: Math.floor(target[1] - defaultRectSize / 2),
            width: defaultRectSize,
            height: defaultRectSize
        } : target;
        let imagePayload = await compositeElementInfoImg({
            inputImgBase64: screenshotBase64,
            size,
            elementsPositionInfo: [
                {
                    rect: targetRect
                }
            ],
            borderThickness: 3
        });
        if (opt?.deepThink) {
            const searchArea = expandSearchArea(targetRect, context.size, vlMode);
            debug('describe: set searchArea', searchArea);
            const croppedResult = await cropByRect(imagePayload, searchArea, 'qwen2.5-vl' === vlMode);
            imagePayload = croppedResult.imageBase64;
        }
        const msgs = [
            {
                role: 'system',
                content: systemPrompt
            },
            {
                role: 'user',
                content: [
                    {
                        type: 'image_url',
                        image_url: {
                            url: imagePayload,
                            detail: 'high'
                        }
                    }
                ]
            }
        ];
        const callAIFn = this.aiVendorFn;
        const res = await callAIFn(msgs, modelConfig);
        const { content } = res;
        assert(!content.error, `describe failed: ${content.error}`);
        assert(content.description, 'failed to describe the element');
        return content;
    }
    constructor(context, opt){
        _define_property(this, "contextRetrieverFn", void 0);
        _define_property(this, "aiVendorFn", callAIWithObjectResponse);
        _define_property(this, "taskInfo", void 0);
        assert(context, 'context is required for Service');
        if ('function' == typeof context) this.contextRetrieverFn = context;
        else this.contextRetrieverFn = ()=>Promise.resolve(context);
        if (void 0 !== opt?.aiVendorFn) this.aiVendorFn = opt.aiVendorFn;
        if (void 0 !== opt?.taskInfo) this.taskInfo = opt.taskInfo;
    }
}
export { Service as default };

//# sourceMappingURL=index.mjs.map