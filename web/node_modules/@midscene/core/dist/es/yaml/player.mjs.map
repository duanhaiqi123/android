{"version":3,"file":"yaml/player.mjs","sources":["../../../src/yaml/player.ts"],"sourcesContent":["import { existsSync, mkdirSync, writeFileSync } from 'node:fs';\nimport { basename, dirname, join, resolve } from 'node:path';\nimport { assert, ifInBrowser, ifInWorker } from '@midscene/shared/utils';\nimport { type ZodTypeAny, z } from 'zod';\n\n// previous defined yaml flow, as a helper\ninterface MidsceneYamlFlowItemAIInput extends LocateOption {\n  // previous version\n  // aiInput: string; // value to input\n  // locate: TUserPrompt; // where to input\n  aiInput: TUserPrompt | undefined; // where to input\n  value: string | number; // value to input\n}\n\ninterface MidsceneYamlFlowItemAIKeyboardPress extends LocateOption {\n  // previous version\n  // aiKeyboardPress: string;\n  // locate?: TUserPrompt; // where to press, optional\n  aiKeyboardPress: TUserPrompt | undefined; // where to press\n  keyName: string; // key to press\n}\n\ninterface MidsceneYamlFlowItemAIScroll extends LocateOption, ScrollParam {\n  // previous version\n  // aiScroll: null;\n  // locate?: TUserPrompt; // which area to scroll, optional\n  aiScroll: TUserPrompt | undefined; // which area to scroll\n}\n\nimport type { Agent } from '@/agent/agent';\nimport type { TUserPrompt } from '@/common';\nimport type {\n  DeviceAction,\n  FreeFn,\n  LocateOption,\n  MidsceneYamlFlowItemAIAction,\n  MidsceneYamlFlowItemAIAssert,\n  MidsceneYamlFlowItemAIWaitFor,\n  MidsceneYamlFlowItemEvaluateJavaScript,\n  MidsceneYamlFlowItemLogScreenshot,\n  MidsceneYamlFlowItemSleep,\n  MidsceneYamlScript,\n  MidsceneYamlScriptEnv,\n  ScriptPlayerStatusValue,\n  ScriptPlayerTaskStatus,\n  ScrollParam,\n} from '@/types';\nimport { getMidsceneRunSubDir } from '@midscene/shared/common';\nimport { getDebug } from '@midscene/shared/logger';\nimport {\n  buildDetailedLocateParam,\n  buildDetailedLocateParamAndRestParams,\n} from './utils';\n\nconst debug = getDebug('yaml-player');\nconst aiTaskHandlerMap = {\n  aiQuery: 'aiQuery',\n  aiNumber: 'aiNumber',\n  aiString: 'aiString',\n  aiBoolean: 'aiBoolean',\n  aiAsk: 'aiAsk',\n  aiLocate: 'aiLocate',\n} as const;\n\ntype AISimpleTaskKey = keyof typeof aiTaskHandlerMap;\n\nconst isStringParamSchema = (schema?: ZodTypeAny): boolean => {\n  if (!schema) {\n    return false;\n  }\n\n  const schemaDef = (schema as any)?._def;\n  if (!schemaDef?.typeName) {\n    return false;\n  }\n\n  switch (schemaDef.typeName) {\n    case z.ZodFirstPartyTypeKind.ZodString:\n    case z.ZodFirstPartyTypeKind.ZodEnum:\n    case z.ZodFirstPartyTypeKind.ZodNativeEnum:\n      return true;\n    case z.ZodFirstPartyTypeKind.ZodLiteral:\n      return typeof schemaDef.value === 'string';\n    case z.ZodFirstPartyTypeKind.ZodOptional:\n    case z.ZodFirstPartyTypeKind.ZodNullable:\n    case z.ZodFirstPartyTypeKind.ZodDefault:\n      return isStringParamSchema(schemaDef.innerType);\n    case z.ZodFirstPartyTypeKind.ZodEffects:\n      return isStringParamSchema(schemaDef.schema);\n    case z.ZodFirstPartyTypeKind.ZodPipeline:\n      return isStringParamSchema(schemaDef.out);\n    case z.ZodFirstPartyTypeKind.ZodUnion: {\n      const options = schemaDef.options as ZodTypeAny[] | undefined;\n      return Array.isArray(options)\n        ? options.every((option) => isStringParamSchema(option))\n        : false;\n    }\n    default:\n      return false;\n  }\n};\nexport class ScriptPlayer<T extends MidsceneYamlScriptEnv> {\n  public currentTaskIndex?: number;\n  public taskStatusList: ScriptPlayerTaskStatus[] = [];\n  public status: ScriptPlayerStatusValue = 'init';\n  public reportFile?: string | null;\n  public result: Record<string, any>;\n  private unnamedResultIndex = 0;\n  public output?: string | null;\n  public unstableLogContent?: string | null;\n  public errorInSetup?: Error;\n  private interfaceAgent: Agent | null = null;\n  public agentStatusTip?: string;\n  public target?: MidsceneYamlScriptEnv;\n  private actionSpace: DeviceAction[] = [];\n  private scriptPath?: string;\n  constructor(\n    private script: MidsceneYamlScript,\n    private setupAgent: (platform: T) => Promise<{\n      agent: Agent;\n      freeFn: FreeFn[];\n    }>,\n    public onTaskStatusChange?: (taskStatus: ScriptPlayerTaskStatus) => void,\n    scriptPath?: string,\n  ) {\n    this.scriptPath = scriptPath;\n    this.result = {};\n    const resolvedAiActContext =\n      script.agent?.aiActContext ?? script.agent?.aiActionContext;\n\n    if (resolvedAiActContext !== undefined && script.agent) {\n      if (\n        script.agent.aiActContext === undefined &&\n        script.agent.aiActionContext !== undefined\n      ) {\n        console.warn(\n          'agent.aiActionContext is deprecated, please use agent.aiActContext instead. The legacy name is still accepted for backward compatibility.',\n        );\n      }\n\n      script.agent.aiActContext = resolvedAiActContext;\n    }\n\n    this.target =\n      script.target ||\n      script.web ||\n      script.android ||\n      script.ios ||\n      script.config;\n\n    if (ifInBrowser || ifInWorker) {\n      this.output = undefined;\n      debug('output is undefined in browser or worker');\n    } else if (this.target?.output) {\n      this.output = resolve(process.cwd(), this.target.output);\n      debug('setting output by config.output', this.output);\n    } else {\n      const scriptName = this.scriptPath\n        ? basename(this.scriptPath, '.yaml').replace(/\\.(ya?ml)$/i, '')\n        : 'script';\n      this.output = join(\n        getMidsceneRunSubDir('output'),\n        `${scriptName}-${Date.now()}.json`,\n      );\n      debug('setting output by script path', this.output);\n    }\n\n    if (ifInBrowser || ifInWorker) {\n      this.unstableLogContent = undefined;\n    } else if (typeof this.target?.unstableLogContent === 'string') {\n      this.unstableLogContent = resolve(\n        process.cwd(),\n        this.target.unstableLogContent,\n      );\n    } else if (this.target?.unstableLogContent === true) {\n      this.unstableLogContent = join(\n        getMidsceneRunSubDir('output'),\n        'unstableLogContent.json',\n      );\n    }\n\n    this.taskStatusList = (script.tasks || []).map((task, taskIndex) => ({\n      ...task,\n      index: taskIndex,\n      status: 'init',\n      totalSteps: task.flow?.length || 0,\n    }));\n  }\n\n  private setResult(key: string | undefined, value: any) {\n    const keyToUse = key || this.unnamedResultIndex++;\n    if (this.result[keyToUse]) {\n      console.warn(`result key ${keyToUse} already exists, will overwrite`);\n    }\n    this.result[keyToUse] = value;\n\n    return this.flushResult();\n  }\n\n  private setPlayerStatus(status: ScriptPlayerStatusValue, error?: Error) {\n    this.status = status;\n    this.errorInSetup = error;\n  }\n\n  private notifyCurrentTaskStatusChange(taskIndex?: number) {\n    const taskIndexToNotify =\n      typeof taskIndex === 'number' ? taskIndex : this.currentTaskIndex;\n\n    if (typeof taskIndexToNotify !== 'number') {\n      return;\n    }\n\n    const taskStatus = this.taskStatusList[taskIndexToNotify];\n    if (this.onTaskStatusChange) {\n      this.onTaskStatusChange(taskStatus);\n    }\n  }\n\n  private async setTaskStatus(\n    index: number,\n    statusValue: ScriptPlayerStatusValue,\n    error?: Error,\n  ) {\n    this.taskStatusList[index].status = statusValue;\n    if (error) {\n      this.taskStatusList[index].error = error;\n    }\n\n    this.notifyCurrentTaskStatusChange(index);\n  }\n\n  private setTaskIndex(taskIndex: number) {\n    this.currentTaskIndex = taskIndex;\n  }\n\n  private flushResult() {\n    if (this.output) {\n      const output = resolve(process.cwd(), this.output);\n      const outputDir = dirname(output);\n      if (!existsSync(outputDir)) {\n        mkdirSync(outputDir, { recursive: true });\n      }\n      writeFileSync(output, JSON.stringify(this.result || {}, undefined, 2));\n    }\n  }\n\n  private flushUnstableLogContent() {\n    if (this.unstableLogContent) {\n      const content = this.interfaceAgent?._unstableLogContent();\n      const filePath = resolve(process.cwd(), this.unstableLogContent);\n      const outputDir = dirname(filePath);\n      if (!existsSync(outputDir)) {\n        mkdirSync(outputDir, { recursive: true });\n      }\n      writeFileSync(filePath, JSON.stringify(content, null, 2));\n    }\n  }\n\n  async playTask(taskStatus: ScriptPlayerTaskStatus, agent: Agent) {\n    const { flow } = taskStatus;\n    assert(flow, 'missing flow in task');\n\n    for (const flowItemIndex in flow) {\n      const currentStep = Number.parseInt(flowItemIndex, 10);\n      taskStatus.currentStep = currentStep;\n      const flowItem = flow[flowItemIndex];\n      debug(\n        `playing step ${flowItemIndex}, flowItem=${JSON.stringify(flowItem)}`,\n      );\n      const simpleAIKey = (\n        Object.keys(aiTaskHandlerMap) as AISimpleTaskKey[]\n      ).find((key) => Object.prototype.hasOwnProperty.call(flowItem, key));\n      if (\n        'aiAct' in (flowItem as MidsceneYamlFlowItemAIAction) ||\n        'aiAction' in (flowItem as MidsceneYamlFlowItemAIAction) ||\n        'ai' in (flowItem as MidsceneYamlFlowItemAIAction)\n      ) {\n        const actionTask = flowItem as MidsceneYamlFlowItemAIAction;\n        const { aiAct, aiAction, ai, ...actionOptions } = actionTask;\n        const prompt = aiAct || aiAction || ai;\n        assert(prompt, 'missing prompt for ai (aiAct)');\n        await agent.aiAct(prompt, actionOptions);\n      } else if ('aiAssert' in (flowItem as MidsceneYamlFlowItemAIAssert)) {\n        const assertTask = flowItem as MidsceneYamlFlowItemAIAssert;\n        const prompt = assertTask.aiAssert;\n        const msg = assertTask.errorMessage;\n        assert(prompt, 'missing prompt for aiAssert');\n        const { pass, thought, message } =\n          (await agent.aiAssert(prompt, msg, {\n            keepRawResponse: true,\n          })) || {};\n\n        this.setResult(assertTask.name, {\n          pass,\n          thought,\n          message,\n        });\n\n        if (!pass) {\n          throw new Error(message);\n        }\n      } else if (simpleAIKey) {\n        const {\n          [simpleAIKey]: prompt,\n          name,\n          ...options\n        } = flowItem as Record<string, any>;\n        assert(prompt, `missing prompt for ${simpleAIKey}`);\n        const agentMethod = (agent as any)[aiTaskHandlerMap[simpleAIKey]];\n        assert(\n          typeof agentMethod === 'function',\n          `missing agent method for ${simpleAIKey}`,\n        );\n        const aiResult = await agentMethod.call(agent, prompt, options);\n        this.setResult(name, aiResult);\n      } else if ('aiWaitFor' in (flowItem as MidsceneYamlFlowItemAIWaitFor)) {\n        const waitForTask = flowItem as MidsceneYamlFlowItemAIWaitFor;\n        const { aiWaitFor, timeout, ...restWaitForOpts } = waitForTask;\n        const prompt = aiWaitFor;\n        assert(prompt, 'missing prompt for aiWaitFor');\n        const waitForOptions = {\n          ...restWaitForOpts,\n          ...(timeout !== undefined ? { timeout, timeoutMs: timeout } : {}),\n        };\n        await agent.aiWaitFor(prompt, waitForOptions);\n      } else if ('sleep' in (flowItem as MidsceneYamlFlowItemSleep)) {\n        const sleepTask = flowItem as MidsceneYamlFlowItemSleep;\n        const ms = sleepTask.sleep;\n        let msNumber = ms;\n        if (typeof ms === 'string') {\n          msNumber = Number.parseInt(ms, 10);\n        }\n        assert(\n          msNumber && msNumber > 0,\n          `ms for sleep must be greater than 0, but got ${ms}`,\n        );\n        await new Promise((resolve) => setTimeout(resolve, msNumber));\n      } else if (\n        'javascript' in (flowItem as MidsceneYamlFlowItemEvaluateJavaScript)\n      ) {\n        const evaluateJavaScriptTask =\n          flowItem as MidsceneYamlFlowItemEvaluateJavaScript;\n\n        const result = await agent.evaluateJavaScript(\n          evaluateJavaScriptTask.javascript,\n        );\n        this.setResult(evaluateJavaScriptTask.name, result);\n      } else if (\n        'logScreenshot' in (flowItem as MidsceneYamlFlowItemLogScreenshot) ||\n        'recordToReport' in (flowItem as MidsceneYamlFlowItemLogScreenshot)\n      ) {\n        const recordTask = flowItem as MidsceneYamlFlowItemLogScreenshot;\n        const title =\n          recordTask.recordToReport ?? recordTask.logScreenshot ?? 'untitled';\n        const content = recordTask.content || '';\n        await agent.recordToReport(title, { content });\n      } else if ('aiInput' in (flowItem as MidsceneYamlFlowItemAIInput)) {\n        // may be input empty string ''\n        const {\n          aiInput,\n          value: rawValue,\n          ...inputTask\n        } = flowItem as MidsceneYamlFlowItemAIInput;\n\n        // Compatibility with previous version:\n        // Old format: { aiInput: string (value), locate: TUserPrompt }\n        // New format - 1: { aiInput: TUserPrompt, value: string | number }\n        // New format - 2: { aiInput: undefined, locate: TUserPrompt, value: string | number }\n        let locatePrompt: TUserPrompt | undefined;\n        let value: string | number | undefined;\n        if ((inputTask as any).locate) {\n          // Old format - aiInput is the value, locate is the prompt\n          // Keep backward compatibility: empty string is treated as no value\n          value = (aiInput as string | number) || rawValue;\n          locatePrompt = (inputTask as any).locate;\n        } else {\n          // New format - aiInput is the prompt, value is the value\n          locatePrompt = aiInput || '';\n          value = rawValue;\n        }\n\n        // Convert value to string for Input action\n        await agent.callActionInActionSpace('Input', {\n          ...inputTask,\n          ...(value !== undefined ? { value: String(value) } : {}),\n          ...(locatePrompt\n            ? { locate: buildDetailedLocateParam(locatePrompt, inputTask) }\n            : {}),\n        });\n      } else if (\n        'aiKeyboardPress' in (flowItem as MidsceneYamlFlowItemAIKeyboardPress)\n      ) {\n        const { aiKeyboardPress, ...keyboardPressTask } =\n          flowItem as MidsceneYamlFlowItemAIKeyboardPress;\n\n        // Compatibility with previous version:\n        // Old format: { aiKeyboardPress: string (key), locate?: TUserPrompt }\n        // New format - 1: { aiKeyboardPress: TUserPrompt, keyName: string }\n        // New format - 2: { aiKeyboardPress: , locate?: TUserPrompt, keyName: string }\n        let locatePrompt: TUserPrompt | undefined;\n        let keyName: string | undefined;\n        if ((keyboardPressTask as any).locate) {\n          // Old format - aiKeyboardPress is the key, locate is the prompt\n          keyName = aiKeyboardPress as string;\n          locatePrompt = (keyboardPressTask as any).locate;\n        } else if (keyboardPressTask.keyName) {\n          // New format - aiKeyboardPress is the prompt, key is the key\n          keyName = keyboardPressTask.keyName;\n          locatePrompt = aiKeyboardPress;\n        } else {\n          keyName = aiKeyboardPress as string;\n        }\n\n        await agent.callActionInActionSpace('KeyboardPress', {\n          ...keyboardPressTask,\n          ...(keyName ? { keyName } : {}),\n          ...(locatePrompt\n            ? {\n                locate: buildDetailedLocateParam(\n                  locatePrompt,\n                  keyboardPressTask,\n                ),\n              }\n            : {}),\n        });\n      } else if ('aiScroll' in (flowItem as MidsceneYamlFlowItemAIScroll)) {\n        const { aiScroll, ...scrollTask } =\n          flowItem as MidsceneYamlFlowItemAIScroll;\n\n        // Compatibility with previous version:\n        // Old format: { aiScroll: null, locate?: TUserPrompt, direction, scrollType, distance? }\n        // New format - 1: { aiScroll: TUserPrompt, direction, scrollType, distance? }\n        // New format - 2: { aiScroll: undefined, locate: TUserPrompt, direction, scrollType, distance? }\n        const { locate, ...scrollOptions } = scrollTask as any;\n        const locatePrompt: TUserPrompt | undefined = locate ?? aiScroll;\n\n        await agent.aiScroll(locatePrompt, scrollOptions);\n      } else {\n        // generic action, find the action in actionSpace\n\n        /* for aiTap, aiRightClick, the parameters are a flattened data for the 'locate', these are all valid data\n\n        - aiTap: 'search input box'\n        - aiTap: 'search input box'\n          deepThink: true\n          cacheable: false\n        - aiTap:\n          prompt: 'search input box'\n        - aiTap:\n          prompt: 'search input box'\n          deepThink: true\n          cacheable: false\n        */\n\n        const actionSpace = this.actionSpace;\n        let locatePromptShortcut: string | undefined;\n        let actionParamForMatchedAction: unknown;\n        const matchedAction = actionSpace.find((action) => {\n          const actionInterfaceAlias = action.interfaceAlias;\n          if (\n            actionInterfaceAlias &&\n            Object.prototype.hasOwnProperty.call(flowItem, actionInterfaceAlias)\n          ) {\n            actionParamForMatchedAction =\n              flowItem[actionInterfaceAlias as keyof typeof flowItem];\n            if (typeof actionParamForMatchedAction === 'string') {\n              locatePromptShortcut = actionParamForMatchedAction;\n            }\n            return true;\n          }\n\n          const keyOfActionInActionSpace = action.name;\n          if (\n            Object.prototype.hasOwnProperty.call(\n              flowItem,\n              keyOfActionInActionSpace,\n            )\n          ) {\n            actionParamForMatchedAction =\n              flowItem[keyOfActionInActionSpace as keyof typeof flowItem];\n            if (typeof actionParamForMatchedAction === 'string') {\n              locatePromptShortcut = actionParamForMatchedAction;\n            }\n            return true;\n          }\n\n          return false;\n        });\n\n        assert(\n          matchedAction,\n          `unknown flowItem in yaml: ${JSON.stringify(flowItem)}`,\n        );\n\n        const schemaIsStringParam = isStringParamSchema(\n          matchedAction.paramSchema,\n        );\n        let stringParamToCall: string | undefined;\n        if (\n          typeof actionParamForMatchedAction === 'string' &&\n          schemaIsStringParam\n        ) {\n          if (matchedAction.paramSchema) {\n            const parseResult = matchedAction.paramSchema.safeParse(\n              actionParamForMatchedAction,\n            );\n            if (parseResult.success && typeof parseResult.data === 'string') {\n              stringParamToCall = parseResult.data;\n            } else if (!parseResult.success) {\n              debug(\n                `parse failed for action ${matchedAction.name} with string param`,\n                parseResult.error,\n              );\n              stringParamToCall = actionParamForMatchedAction;\n            }\n          } else {\n            stringParamToCall = actionParamForMatchedAction;\n          }\n        }\n\n        if (stringParamToCall !== undefined) {\n          debug(\n            `matchedAction: ${matchedAction.name}`,\n            `flowParams: ${JSON.stringify(stringParamToCall)}`,\n          );\n          const result = await agent.callActionInActionSpace(\n            matchedAction.name,\n            stringParamToCall,\n          );\n\n          // Store result if there's a name property in flowItem\n          const resultName = (flowItem as any).name;\n          if (result !== undefined) {\n            this.setResult(resultName, result);\n          }\n        } else {\n          // Determine the source for parameter extraction:\n          // - If we have a locatePromptShortcut, use the flowItem (for actions like aiTap with prompt)\n          // - Otherwise, use actionParamForMatchedAction (for actions like runWdaRequest with structured params)\n          const sourceForParams =\n            locatePromptShortcut &&\n            typeof actionParamForMatchedAction === 'string'\n              ? { ...flowItem, prompt: locatePromptShortcut }\n              : typeof actionParamForMatchedAction === 'object' &&\n                  actionParamForMatchedAction !== null\n                ? actionParamForMatchedAction\n                : flowItem;\n\n          const { locateParam, restParams } =\n            buildDetailedLocateParamAndRestParams(\n              locatePromptShortcut || '',\n              sourceForParams as LocateOption,\n              [\n                matchedAction.name,\n                matchedAction.interfaceAlias || '_never_mind_',\n              ],\n            );\n\n          const flowParams = {\n            ...restParams,\n            locate: locateParam,\n          };\n\n          debug(\n            `matchedAction: ${matchedAction.name}`,\n            `flowParams: ${JSON.stringify(flowParams, null, 2)}`,\n          );\n          const result = await agent.callActionInActionSpace(\n            matchedAction.name,\n            flowParams,\n          );\n\n          // Store result if there's a name property in flowItem\n          const resultName = (flowItem as any).name;\n          if (result !== undefined) {\n            this.setResult(resultName, result);\n          }\n        }\n      }\n    }\n    this.reportFile = agent.reportFile;\n    await this.flushUnstableLogContent();\n  }\n\n  async run() {\n    const { target, web, android, ios, tasks } = this.script;\n    const webEnv = web || target;\n    const androidEnv = android;\n    const iosEnv = ios;\n    const platform = webEnv || androidEnv || iosEnv;\n\n    this.setPlayerStatus('running');\n\n    let agent: Agent | null = null;\n    let freeFn: FreeFn[] = [];\n    try {\n      const { agent: newAgent, freeFn: newFreeFn } = await this.setupAgent(\n        platform as T,\n      );\n      this.actionSpace = await newAgent.getActionSpace();\n      agent = newAgent;\n      const originalOnTaskStartTip = agent.onTaskStartTip;\n      agent.onTaskStartTip = (tip) => {\n        if (this.status === 'running') {\n          this.agentStatusTip = tip;\n        }\n        originalOnTaskStartTip?.(tip);\n      };\n      freeFn = [\n        ...(newFreeFn || []),\n        {\n          name: 'restore-agent-onTaskStartTip',\n          fn: () => {\n            if (agent) {\n              agent.onTaskStartTip = originalOnTaskStartTip;\n            }\n          },\n        },\n      ];\n    } catch (e) {\n      this.setPlayerStatus('error', e as Error);\n      return;\n    }\n    this.interfaceAgent = agent;\n\n    let taskIndex = 0;\n    this.setPlayerStatus('running');\n    let errorFlag = false;\n    while (taskIndex < tasks.length) {\n      const taskStatus = this.taskStatusList[taskIndex];\n      this.setTaskStatus(taskIndex, 'running' as any);\n      this.setTaskIndex(taskIndex);\n\n      try {\n        await this.playTask(taskStatus, this.interfaceAgent);\n        this.setTaskStatus(taskIndex, 'done' as any);\n      } catch (e) {\n        this.setTaskStatus(taskIndex, 'error' as any, e as Error);\n\n        if (taskStatus.continueOnError) {\n          // nothing more to do\n        } else {\n          this.reportFile = agent.reportFile;\n          errorFlag = true;\n          break;\n        }\n      }\n      this.reportFile = agent?.reportFile;\n      taskIndex++;\n    }\n\n    if (errorFlag) {\n      this.setPlayerStatus('error');\n    } else {\n      this.setPlayerStatus('done');\n    }\n    this.agentStatusTip = '';\n\n    // free the resources\n    for (const fn of freeFn) {\n      try {\n        // console.log('freeing', fn.name);\n        await fn.fn();\n        // console.log('freed', fn.name);\n      } catch (e) {\n        // console.error('error freeing', fn.name, e);\n      }\n    }\n  }\n}\n"],"names":["debug","getDebug","aiTaskHandlerMap","isStringParamSchema","schema","schemaDef","z","options","Array","option","ScriptPlayer","key","value","keyToUse","console","status","error","taskIndex","taskIndexToNotify","taskStatus","index","statusValue","output","resolve","process","outputDir","dirname","existsSync","mkdirSync","writeFileSync","JSON","undefined","content","filePath","agent","flow","assert","flowItemIndex","currentStep","Number","flowItem","simpleAIKey","Object","actionTask","aiAct","aiAction","ai","actionOptions","prompt","assertTask","msg","pass","thought","message","Error","name","agentMethod","aiResult","waitForTask","aiWaitFor","timeout","restWaitForOpts","waitForOptions","sleepTask","ms","msNumber","Promise","setTimeout","evaluateJavaScriptTask","result","recordTask","title","aiInput","rawValue","inputTask","locatePrompt","String","buildDetailedLocateParam","aiKeyboardPress","keyboardPressTask","keyName","aiScroll","scrollTask","locate","scrollOptions","actionSpace","locatePromptShortcut","actionParamForMatchedAction","matchedAction","action","actionInterfaceAlias","keyOfActionInActionSpace","schemaIsStringParam","stringParamToCall","parseResult","resultName","sourceForParams","locateParam","restParams","buildDetailedLocateParamAndRestParams","flowParams","target","web","android","ios","tasks","webEnv","androidEnv","iosEnv","platform","freeFn","newAgent","newFreeFn","originalOnTaskStartTip","tip","e","errorFlag","fn","script","setupAgent","onTaskStatusChange","scriptPath","resolvedAiActContext","ifInBrowser","ifInWorker","scriptName","basename","join","getMidsceneRunSubDir","Date","task"],"mappings":";;;;;;;;;;;;;;;;;AAsDA,MAAMA,QAAQC,SAAS;AACvB,MAAMC,mBAAmB;IACvB,SAAS;IACT,UAAU;IACV,UAAU;IACV,WAAW;IACX,OAAO;IACP,UAAU;AACZ;AAIA,MAAMC,sBAAsB,CAACC;IAC3B,IAAI,CAACA,QACH,OAAO;IAGT,MAAMC,YAAaD,QAAgB;IACnC,IAAI,CAACC,WAAW,UACd,OAAO;IAGT,OAAQA,UAAU,QAAQ;QACxB,KAAKC,EAAE,qBAAqB,CAAC,SAAS;QACtC,KAAKA,EAAE,qBAAqB,CAAC,OAAO;QACpC,KAAKA,EAAE,qBAAqB,CAAC,aAAa;YACxC,OAAO;QACT,KAAKA,EAAE,qBAAqB,CAAC,UAAU;YACrC,OAAO,AAA2B,YAA3B,OAAOD,UAAU,KAAK;QAC/B,KAAKC,EAAE,qBAAqB,CAAC,WAAW;QACxC,KAAKA,EAAE,qBAAqB,CAAC,WAAW;QACxC,KAAKA,EAAE,qBAAqB,CAAC,UAAU;YACrC,OAAOH,oBAAoBE,UAAU,SAAS;QAChD,KAAKC,EAAE,qBAAqB,CAAC,UAAU;YACrC,OAAOH,oBAAoBE,UAAU,MAAM;QAC7C,KAAKC,EAAE,qBAAqB,CAAC,WAAW;YACtC,OAAOH,oBAAoBE,UAAU,GAAG;QAC1C,KAAKC,EAAE,qBAAqB,CAAC,QAAQ;YAAE;gBACrC,MAAMC,UAAUF,UAAU,OAAO;gBACjC,OAAOG,MAAM,OAAO,CAACD,WACjBA,QAAQ,KAAK,CAAC,CAACE,SAAWN,oBAAoBM,WAC9C;YACN;QACA;YACE,OAAO;IACX;AACF;AACO,MAAMC;IAwFH,UAAUC,GAAuB,EAAEC,KAAU,EAAE;QACrD,MAAMC,WAAWF,OAAO,IAAI,CAAC,kBAAkB;QAC/C,IAAI,IAAI,CAAC,MAAM,CAACE,SAAS,EACvBC,QAAQ,IAAI,CAAC,CAAC,WAAW,EAAED,SAAS,+BAA+B,CAAC;QAEtE,IAAI,CAAC,MAAM,CAACA,SAAS,GAAGD;QAExB,OAAO,IAAI,CAAC,WAAW;IACzB;IAEQ,gBAAgBG,MAA+B,EAAEC,KAAa,EAAE;QACtE,IAAI,CAAC,MAAM,GAAGD;QACd,IAAI,CAAC,YAAY,GAAGC;IACtB;IAEQ,8BAA8BC,SAAkB,EAAE;QACxD,MAAMC,oBACJ,AAAqB,YAArB,OAAOD,YAAyBA,YAAY,IAAI,CAAC,gBAAgB;QAEnE,IAAI,AAA6B,YAA7B,OAAOC,mBACT;QAGF,MAAMC,aAAa,IAAI,CAAC,cAAc,CAACD,kBAAkB;QACzD,IAAI,IAAI,CAAC,kBAAkB,EACzB,IAAI,CAAC,kBAAkB,CAACC;IAE5B;IAEA,MAAc,cACZC,KAAa,EACbC,WAAoC,EACpCL,KAAa,EACb;QACA,IAAI,CAAC,cAAc,CAACI,MAAM,CAAC,MAAM,GAAGC;QACpC,IAAIL,OACF,IAAI,CAAC,cAAc,CAACI,MAAM,CAAC,KAAK,GAAGJ;QAGrC,IAAI,CAAC,6BAA6B,CAACI;IACrC;IAEQ,aAAaH,SAAiB,EAAE;QACtC,IAAI,CAAC,gBAAgB,GAAGA;IAC1B;IAEQ,cAAc;QACpB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,MAAMK,SAASC,2BAAQC,QAAQ,GAAG,IAAI,IAAI,CAAC,MAAM;YACjD,MAAMC,YAAYC,QAAQJ;YAC1B,IAAI,CAACK,WAAWF,YACdG,UAAUH,WAAW;gBAAE,WAAW;YAAK;YAEzCI,cAAcP,QAAQQ,KAAK,SAAS,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,GAAGC,QAAW;QACrE;IACF;IAEQ,0BAA0B;QAChC,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3B,MAAMC,UAAU,IAAI,CAAC,cAAc,EAAE;YACrC,MAAMC,WAAWV,2BAAQC,QAAQ,GAAG,IAAI,IAAI,CAAC,kBAAkB;YAC/D,MAAMC,YAAYC,QAAQO;YAC1B,IAAI,CAACN,WAAWF,YACdG,UAAUH,WAAW;gBAAE,WAAW;YAAK;YAEzCI,cAAcI,UAAUH,KAAK,SAAS,CAACE,SAAS,MAAM;QACxD;IACF;IAEA,MAAM,SAASb,UAAkC,EAAEe,KAAY,EAAE;QAC/D,MAAM,EAAEC,IAAI,EAAE,GAAGhB;QACjBiB,OAAOD,MAAM;QAEb,IAAK,MAAME,iBAAiBF,KAAM;YAChC,MAAMG,cAAcC,OAAO,QAAQ,CAACF,eAAe;YACnDlB,WAAW,WAAW,GAAGmB;YACzB,MAAME,WAAWL,IAAI,CAACE,cAAc;YACpCrC,MACE,CAAC,aAAa,EAAEqC,cAAc,WAAW,EAAEP,KAAK,SAAS,CAACU,WAAW;YAEvE,MAAMC,cACJC,OAAO,IAAI,CAACxC,kBACZ,IAAI,CAAC,CAACS,MAAQ+B,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAACF,UAAU7B;YAC/D,IACE,WAAY6B,YACZ,cAAeA,YACf,QAASA,UACT;gBACA,MAAMG,aAAaH;gBACnB,MAAM,EAAEI,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE,GAAGC,eAAe,GAAGJ;gBAClD,MAAMK,SAASJ,SAASC,YAAYC;gBACpCV,OAAOY,QAAQ;gBACf,MAAMd,MAAM,KAAK,CAACc,QAAQD;YAC5B,OAAO,IAAI,cAAeP,UAA2C;gBACnE,MAAMS,aAAaT;gBACnB,MAAMQ,SAASC,WAAW,QAAQ;gBAClC,MAAMC,MAAMD,WAAW,YAAY;gBACnCb,OAAOY,QAAQ;gBACf,MAAM,EAAEG,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAE,GAC7B,MAAMnB,MAAM,QAAQ,CAACc,QAAQE,KAAK;oBACjC,iBAAiB;gBACnB,MAAO,CAAC;gBAEV,IAAI,CAAC,SAAS,CAACD,WAAW,IAAI,EAAE;oBAC9BE;oBACAC;oBACAC;gBACF;gBAEA,IAAI,CAACF,MACH,MAAM,IAAIG,MAAMD;YAEpB,OAAO,IAAIZ,aAAa;gBACtB,MAAM,EACJ,CAACA,YAAY,EAAEO,MAAM,EACrBO,IAAI,EACJ,GAAGhD,SACJ,GAAGiC;gBACJJ,OAAOY,QAAQ,CAAC,mBAAmB,EAAEP,aAAa;gBAClD,MAAMe,cAAetB,KAAa,CAAChC,gBAAgB,CAACuC,YAAY,CAAC;gBACjEL,OACE,AAAuB,cAAvB,OAAOoB,aACP,CAAC,yBAAyB,EAAEf,aAAa;gBAE3C,MAAMgB,WAAW,MAAMD,YAAY,IAAI,CAACtB,OAAOc,QAAQzC;gBACvD,IAAI,CAAC,SAAS,CAACgD,MAAME;YACvB,OAAO,IAAI,eAAgBjB,UAA4C;gBACrE,MAAMkB,cAAclB;gBACpB,MAAM,EAAEmB,SAAS,EAAEC,OAAO,EAAE,GAAGC,iBAAiB,GAAGH;gBACnD,MAAMV,SAASW;gBACfvB,OAAOY,QAAQ;gBACf,MAAMc,iBAAiB;oBACrB,GAAGD,eAAe;oBAClB,GAAID,AAAY7B,WAAZ6B,UAAwB;wBAAEA;wBAAS,WAAWA;oBAAQ,IAAI,CAAC,CAAC;gBAClE;gBACA,MAAM1B,MAAM,SAAS,CAACc,QAAQc;YAChC,OAAO,IAAI,WAAYtB,UAAwC;gBAC7D,MAAMuB,YAAYvB;gBAClB,MAAMwB,KAAKD,UAAU,KAAK;gBAC1B,IAAIE,WAAWD;gBACf,IAAI,AAAc,YAAd,OAAOA,IACTC,WAAW1B,OAAO,QAAQ,CAACyB,IAAI;gBAEjC5B,OACE6B,YAAYA,WAAW,GACvB,CAAC,6CAA6C,EAAED,IAAI;gBAEtD,MAAM,IAAIE,QAAQ,CAAC3C,UAAY4C,WAAW5C,SAAS0C;YACrD,OAAO,IACL,gBAAiBzB,UACjB;gBACA,MAAM4B,yBACJ5B;gBAEF,MAAM6B,SAAS,MAAMnC,MAAM,kBAAkB,CAC3CkC,uBAAuB,UAAU;gBAEnC,IAAI,CAAC,SAAS,CAACA,uBAAuB,IAAI,EAAEC;YAC9C,OAAO,IACL,mBAAoB7B,YACpB,oBAAqBA,UACrB;gBACA,MAAM8B,aAAa9B;gBACnB,MAAM+B,QACJD,WAAW,cAAc,IAAIA,WAAW,aAAa,IAAI;gBAC3D,MAAMtC,UAAUsC,WAAW,OAAO,IAAI;gBACtC,MAAMpC,MAAM,cAAc,CAACqC,OAAO;oBAAEvC;gBAAQ;YAC9C,OAAO,IAAI,aAAcQ,UAA0C;gBAEjE,MAAM,EACJgC,OAAO,EACP,OAAOC,QAAQ,EACf,GAAGC,WACJ,GAAGlC;gBAMJ,IAAImC;gBACJ,IAAI/D;gBACJ,IAAK8D,UAAkB,MAAM,EAAE;oBAG7B9D,QAAS4D,WAA+BC;oBACxCE,eAAgBD,UAAkB,MAAM;gBAC1C,OAAO;oBAELC,eAAeH,WAAW;oBAC1B5D,QAAQ6D;gBACV;gBAGA,MAAMvC,MAAM,uBAAuB,CAAC,SAAS;oBAC3C,GAAGwC,SAAS;oBACZ,GAAI9D,AAAUmB,WAAVnB,QAAsB;wBAAE,OAAOgE,OAAOhE;oBAAO,IAAI,CAAC,CAAC;oBACvD,GAAI+D,eACA;wBAAE,QAAQE,yBAAyBF,cAAcD;oBAAW,IAC5D,CAAC,CAAC;gBACR;YACF,OAAO,IACL,qBAAsBlC,UACtB;gBACA,MAAM,EAAEsC,eAAe,EAAE,GAAGC,mBAAmB,GAC7CvC;gBAMF,IAAImC;gBACJ,IAAIK;gBACJ,IAAKD,kBAA0B,MAAM,EAAE;oBAErCC,UAAUF;oBACVH,eAAgBI,kBAA0B,MAAM;gBAClD,OAAO,IAAIA,kBAAkB,OAAO,EAAE;oBAEpCC,UAAUD,kBAAkB,OAAO;oBACnCJ,eAAeG;gBACjB,OACEE,UAAUF;gBAGZ,MAAM5C,MAAM,uBAAuB,CAAC,iBAAiB;oBACnD,GAAG6C,iBAAiB;oBACpB,GAAIC,UAAU;wBAAEA;oBAAQ,IAAI,CAAC,CAAC;oBAC9B,GAAIL,eACA;wBACE,QAAQE,yBACNF,cACAI;oBAEJ,IACA,CAAC,CAAC;gBACR;YACF,OAAO,IAAI,cAAevC,UAA2C;gBACnE,MAAM,EAAEyC,QAAQ,EAAE,GAAGC,YAAY,GAC/B1C;gBAMF,MAAM,EAAE2C,MAAM,EAAE,GAAGC,eAAe,GAAGF;gBACrC,MAAMP,eAAwCQ,UAAUF;gBAExD,MAAM/C,MAAM,QAAQ,CAACyC,cAAcS;YACrC,OAAO;gBAiBL,MAAMC,cAAc,IAAI,CAAC,WAAW;gBACpC,IAAIC;gBACJ,IAAIC;gBACJ,MAAMC,gBAAgBH,YAAY,IAAI,CAAC,CAACI;oBACtC,MAAMC,uBAAuBD,OAAO,cAAc;oBAClD,IACEC,wBACAhD,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAACF,UAAUkD,uBAC/C;wBACAH,8BACE/C,QAAQ,CAACkD,qBAA8C;wBACzD,IAAI,AAAuC,YAAvC,OAAOH,6BACTD,uBAAuBC;wBAEzB,OAAO;oBACT;oBAEA,MAAMI,2BAA2BF,OAAO,IAAI;oBAC5C,IACE/C,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAClCF,UACAmD,2BAEF;wBACAJ,8BACE/C,QAAQ,CAACmD,yBAAkD;wBAC7D,IAAI,AAAuC,YAAvC,OAAOJ,6BACTD,uBAAuBC;wBAEzB,OAAO;oBACT;oBAEA,OAAO;gBACT;gBAEAnD,OACEoD,eACA,CAAC,0BAA0B,EAAE1D,KAAK,SAAS,CAACU,WAAW;gBAGzD,MAAMoD,sBAAsBzF,oBAC1BqF,cAAc,WAAW;gBAE3B,IAAIK;gBACJ,IACE,AAAuC,YAAvC,OAAON,+BACPK,qBAEA,IAAIJ,cAAc,WAAW,EAAE;oBAC7B,MAAMM,cAAcN,cAAc,WAAW,CAAC,SAAS,CACrDD;oBAEF,IAAIO,YAAY,OAAO,IAAI,AAA4B,YAA5B,OAAOA,YAAY,IAAI,EAChDD,oBAAoBC,YAAY,IAAI;yBAC/B,IAAI,CAACA,YAAY,OAAO,EAAE;wBAC/B9F,MACE,CAAC,wBAAwB,EAAEwF,cAAc,IAAI,CAAC,kBAAkB,CAAC,EACjEM,YAAY,KAAK;wBAEnBD,oBAAoBN;oBACtB;gBACF,OACEM,oBAAoBN;gBAIxB,IAAIM,AAAsB9D,WAAtB8D,mBAAiC;oBACnC7F,MACE,CAAC,eAAe,EAAEwF,cAAc,IAAI,EAAE,EACtC,CAAC,YAAY,EAAE1D,KAAK,SAAS,CAAC+D,oBAAoB;oBAEpD,MAAMxB,SAAS,MAAMnC,MAAM,uBAAuB,CAChDsD,cAAc,IAAI,EAClBK;oBAIF,MAAME,aAAcvD,SAAiB,IAAI;oBACzC,IAAI6B,AAAWtC,WAAXsC,QACF,IAAI,CAAC,SAAS,CAAC0B,YAAY1B;gBAE/B,OAAO;oBAIL,MAAM2B,kBACJV,wBACA,AAAuC,YAAvC,OAAOC,8BACH;wBAAE,GAAG/C,QAAQ;wBAAE,QAAQ8C;oBAAqB,IAC5C,AAAuC,YAAvC,OAAOC,+BACLA,AAAgC,SAAhCA,8BACAA,8BACA/C;oBAER,MAAM,EAAEyD,WAAW,EAAEC,UAAU,EAAE,GAC/BC,sCACEb,wBAAwB,IACxBU,iBACA;wBACER,cAAc,IAAI;wBAClBA,cAAc,cAAc,IAAI;qBACjC;oBAGL,MAAMY,aAAa;wBACjB,GAAGF,UAAU;wBACb,QAAQD;oBACV;oBAEAjG,MACE,CAAC,eAAe,EAAEwF,cAAc,IAAI,EAAE,EACtC,CAAC,YAAY,EAAE1D,KAAK,SAAS,CAACsE,YAAY,MAAM,IAAI;oBAEtD,MAAM/B,SAAS,MAAMnC,MAAM,uBAAuB,CAChDsD,cAAc,IAAI,EAClBY;oBAIF,MAAML,aAAcvD,SAAiB,IAAI;oBACzC,IAAI6B,AAAWtC,WAAXsC,QACF,IAAI,CAAC,SAAS,CAAC0B,YAAY1B;gBAE/B;YACF;QACF;QACA,IAAI,CAAC,UAAU,GAAGnC,MAAM,UAAU;QAClC,MAAM,IAAI,CAAC,uBAAuB;IACpC;IAEA,MAAM,MAAM;QACV,MAAM,EAAEmE,MAAM,EAAEC,GAAG,EAAEC,OAAO,EAAEC,GAAG,EAAEC,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM;QACxD,MAAMC,SAASJ,OAAOD;QACtB,MAAMM,aAAaJ;QACnB,MAAMK,SAASJ;QACf,MAAMK,WAAWH,UAAUC,cAAcC;QAEzC,IAAI,CAAC,eAAe,CAAC;QAErB,IAAI1E,QAAsB;QAC1B,IAAI4E,SAAmB,EAAE;QACzB,IAAI;YACF,MAAM,EAAE,OAAOC,QAAQ,EAAE,QAAQC,SAAS,EAAE,GAAG,MAAM,IAAI,CAAC,UAAU,CAClEH;YAEF,IAAI,CAAC,WAAW,GAAG,MAAME,SAAS,cAAc;YAChD7E,QAAQ6E;YACR,MAAME,yBAAyB/E,MAAM,cAAc;YACnDA,MAAM,cAAc,GAAG,CAACgF;gBACtB,IAAI,AAAgB,cAAhB,IAAI,CAAC,MAAM,EACb,IAAI,CAAC,cAAc,GAAGA;gBAExBD,yBAAyBC;YAC3B;YACAJ,SAAS;mBACHE,aAAa,EAAE;gBACnB;oBACE,MAAM;oBACN,IAAI;wBACF,IAAI9E,OACFA,MAAM,cAAc,GAAG+E;oBAE3B;gBACF;aACD;QACH,EAAE,OAAOE,GAAG;YACV,IAAI,CAAC,eAAe,CAAC,SAASA;YAC9B;QACF;QACA,IAAI,CAAC,cAAc,GAAGjF;QAEtB,IAAIjB,YAAY;QAChB,IAAI,CAAC,eAAe,CAAC;QACrB,IAAImG,YAAY;QAChB,MAAOnG,YAAYwF,MAAM,MAAM,CAAE;YAC/B,MAAMtF,aAAa,IAAI,CAAC,cAAc,CAACF,UAAU;YACjD,IAAI,CAAC,aAAa,CAACA,WAAW;YAC9B,IAAI,CAAC,YAAY,CAACA;YAElB,IAAI;gBACF,MAAM,IAAI,CAAC,QAAQ,CAACE,YAAY,IAAI,CAAC,cAAc;gBACnD,IAAI,CAAC,aAAa,CAACF,WAAW;YAChC,EAAE,OAAOkG,GAAG;gBACV,IAAI,CAAC,aAAa,CAAClG,WAAW,SAAgBkG;gBAE9C,IAAIhG,WAAW,eAAe;qBAEvB;oBACL,IAAI,CAAC,UAAU,GAAGe,MAAM,UAAU;oBAClCkF,YAAY;oBACZ;gBACF;YACF;YACA,IAAI,CAAC,UAAU,GAAGlF,OAAO;YACzBjB;QACF;QAEA,IAAImG,WACF,IAAI,CAAC,eAAe,CAAC;aAErB,IAAI,CAAC,eAAe,CAAC;QAEvB,IAAI,CAAC,cAAc,GAAG;QAGtB,KAAK,MAAMC,MAAMP,OACf,IAAI;YAEF,MAAMO,GAAG,EAAE;QAEb,EAAE,OAAOF,GAAG,CAEZ;IAEJ;IAxiBA,YACUG,MAA0B,EAC1BC,UAGN,EACKC,kBAAiE,EACxEC,UAAmB,CACnB;;;;QAtBF,uBAAO,oBAAP;QACA,uBAAO,kBAAP;QACA,uBAAO,UAAP;QACA,uBAAO,cAAP;QACA,uBAAO,UAAP;QACA,uBAAQ,sBAAR;QACA,uBAAO,UAAP;QACA,uBAAO,sBAAP;QACA,uBAAO,gBAAP;QACA,uBAAQ,kBAAR;QACA,uBAAO,kBAAP;QACA,uBAAO,UAAP;QACA,uBAAQ,eAAR;QACA,uBAAQ,cAAR;aAEUH,MAAM,GAANA;aACAC,UAAU,GAAVA;aAIDC,kBAAkB,GAAlBA;aAnBF,cAAc,GAA6B,EAAE;aAC7C,MAAM,GAA4B;aAGjC,kBAAkB,GAAG;aAIrB,cAAc,GAAiB;aAG/B,WAAW,GAAmB,EAAE;QAWtC,IAAI,CAAC,UAAU,GAAGC;QAClB,IAAI,CAAC,MAAM,GAAG,CAAC;QACf,MAAMC,uBACJJ,OAAO,KAAK,EAAE,gBAAgBA,OAAO,KAAK,EAAE;QAE9C,IAAII,AAAyB3F,WAAzB2F,wBAAsCJ,OAAO,KAAK,EAAE;YACtD,IACEA,AAA8BvF,WAA9BuF,OAAO,KAAK,CAAC,YAAY,IACzBA,AAAiCvF,WAAjCuF,OAAO,KAAK,CAAC,eAAe,EAE5BxG,QAAQ,IAAI,CACV;YAIJwG,OAAO,KAAK,CAAC,YAAY,GAAGI;QAC9B;QAEA,IAAI,CAAC,MAAM,GACTJ,OAAO,MAAM,IACbA,OAAO,GAAG,IACVA,OAAO,OAAO,IACdA,OAAO,GAAG,IACVA,OAAO,MAAM;QAEf,IAAIK,eAAeC,YAAY;YAC7B,IAAI,CAAC,MAAM,GAAG7F;YACd/B,MAAM;QACR,OAAO,IAAI,IAAI,CAAC,MAAM,EAAE,QAAQ;YAC9B,IAAI,CAAC,MAAM,GAAGuB,2BAAQC,QAAQ,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM;YACvDxB,MAAM,mCAAmC,IAAI,CAAC,MAAM;QACtD,OAAO;YACL,MAAM6H,aAAa,IAAI,CAAC,UAAU,GAC9BC,SAAS,IAAI,CAAC,UAAU,EAAE,SAAS,OAAO,CAAC,eAAe,MAC1D;YACJ,IAAI,CAAC,MAAM,GAAGC,KACZC,qBAAqB,WACrB,GAAGH,WAAW,CAAC,EAAEI,KAAK,GAAG,GAAG,KAAK,CAAC;YAEpCjI,MAAM,iCAAiC,IAAI,CAAC,MAAM;QACpD;QAEA,IAAI2H,eAAeC,YACjB,IAAI,CAAC,kBAAkB,GAAG7F;aACrB,IAAI,AAA2C,YAA3C,OAAO,IAAI,CAAC,MAAM,EAAE,oBAC7B,IAAI,CAAC,kBAAkB,GAAGR,2BACxBC,QAAQ,GAAG,IACX,IAAI,CAAC,MAAM,CAAC,kBAAkB;aAE3B,IAAI,IAAI,CAAC,MAAM,EAAE,uBAAuB,MAC7C,IAAI,CAAC,kBAAkB,GAAGuG,KACxBC,qBAAqB,WACrB;QAIJ,IAAI,CAAC,cAAc,GAAIV,AAAAA,CAAAA,OAAO,KAAK,IAAI,EAAC,EAAG,GAAG,CAAC,CAACY,MAAMjH,YAAe;gBACnE,GAAGiH,IAAI;gBACP,OAAOjH;gBACP,QAAQ;gBACR,YAAYiH,KAAK,IAAI,EAAE,UAAU;YACnC;IACF;AAkeF"}