import { parseBase64 } from "@midscene/shared/img";
import { getDebug } from "@midscene/shared/logger";
import { generateCommonTools, generateToolsFromActionSpace } from "./tool-generator.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const debug = getDebug('mcp:base-tools');
class BaseMidsceneTools {
    preparePlatformTools() {
        return [];
    }
    async initTools() {
        this.toolDefinitions = [];
        const platformTools = this.preparePlatformTools();
        this.toolDefinitions.push(...platformTools);
        let actionSpace;
        try {
            const agent = await this.ensureAgent();
            actionSpace = await agent.getActionSpace();
            debug('Action space from connected agent:', actionSpace.map((a)=>a.name).join(', '));
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            errorMessage.includes('requires a URL') || errorMessage.includes('web_connect') ? debug('Bridge mode detected - agent will be initialized on first web_connect call') : debug('Agent not available yet, using temporary device for action space');
            const tempDevice = this.createTemporaryDevice();
            actionSpace = tempDevice.actionSpace();
            debug('Action space from temporary device:', actionSpace.map((a)=>a.name).join(', '));
            await tempDevice.destroy?.();
        }
        const actionTools = generateToolsFromActionSpace(actionSpace, ()=>this.ensureAgent());
        const commonTools = generateCommonTools(()=>this.ensureAgent());
        this.toolDefinitions.push(...actionTools, ...commonTools);
        debug('Total tools prepared:', this.toolDefinitions.length);
    }
    attachToServer(server) {
        this.mcpServer = server;
        if (0 === this.toolDefinitions.length) debug('Warning: No tools to register. Tools may be initialized lazily.');
        for (const toolDef of this.toolDefinitions)if (toolDef.autoDestroy) this.toolWithAutoDestroy(toolDef.name, toolDef.description, toolDef.schema, toolDef.handler);
        else this.mcpServer.tool(toolDef.name, toolDef.description, toolDef.schema, toolDef.handler);
        debug('Registered', this.toolDefinitions.length, 'tools');
    }
    toolWithAutoDestroy(name, description, schema, handler) {
        if (!this.mcpServer) throw new Error('MCP server not attached');
        this.mcpServer.tool(name, description, schema, async (...args)=>{
            try {
                return await handler(...args);
            } finally{
                if (!process.env.MIDSCENE_MCP_DISABLE_AGENT_AUTO_DESTROY) {
                    try {
                        await this.agent?.destroy?.();
                    } catch (error) {
                        debug('Failed to destroy agent during cleanup:', error);
                    }
                    this.agent = void 0;
                }
            }
        });
    }
    async closeBrowser() {
        await this.agent?.destroy?.();
    }
    getToolDefinitions() {
        return this.toolDefinitions;
    }
    setAgent(agent) {
        this.agent = agent;
    }
    buildScreenshotContent(screenshot) {
        const { mimeType, body } = parseBase64(screenshot);
        return [
            {
                type: 'image',
                data: body,
                mimeType
            }
        ];
    }
    constructor(){
        _define_property(this, "mcpServer", void 0);
        _define_property(this, "agent", void 0);
        _define_property(this, "toolDefinitions", []);
    }
}
export { BaseMidsceneTools };
