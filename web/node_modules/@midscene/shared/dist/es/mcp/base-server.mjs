import { randomUUID } from "node:crypto";
import { setIsMcp } from "@midscene/shared/utils";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import express from "express";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const CLI_ARGS_CONFIG = {
    mode: {
        type: 'string',
        default: 'stdio'
    },
    port: {
        type: 'string',
        default: '3000'
    },
    host: {
        type: 'string',
        default: 'localhost'
    }
};
function launchMCPServer(server, args) {
    if ('http' === args.mode) return server.launchHttp({
        port: Number.parseInt(args.port || '3000', 10),
        host: args.host || 'localhost'
    });
    return server.launch();
}
const SESSION_TIMEOUT_MS = 1800000;
const CLEANUP_INTERVAL_MS = 300000;
const MAX_SESSIONS = 100;
class BaseMCPServer {
    async initializeToolsManager() {
        setIsMcp(true);
        this.toolsManager = this.providedToolsManager || this.createToolsManager();
        try {
            await this.toolsManager.initTools();
        } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            console.error(`Failed to initialize tools: ${message}`);
            console.error('Tools will be initialized on first use');
        }
        this.toolsManager.attachToServer(this.mcpServer);
    }
    performCleanup() {
        console.error(`${this.config.name} closing...`);
        this.mcpServer.close();
        this.toolsManager?.closeBrowser?.().catch(console.error);
    }
    async launch() {
        console.log = (...args)=>{
            console.error('[LOG]', ...args);
        };
        console.info = (...args)=>{
            console.error('[INFO]', ...args);
        };
        console.debug = (...args)=>{
            console.error('[DEBUG]', ...args);
        };
        await this.initializeToolsManager();
        const transport = new StdioServerTransport();
        try {
            await this.mcpServer.connect(transport);
        } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            console.error(`Failed to connect MCP stdio transport: ${message}`);
            throw new Error(`Failed to initialize MCP stdio transport: ${message}`);
        }
        process.on('uncaughtException', (error)=>{
            console.error(`[${this.config.name}] Uncaught Exception:`, error);
            console.error('Stack:', error.stack);
        });
        process.on('unhandledRejection', (reason)=>{
            console.error(`[${this.config.name}] Unhandled Rejection:`, reason);
            if (reason instanceof Error) console.error('Stack:', reason.stack);
        });
        process.stdin.on('close', ()=>this.performCleanup());
        const cleanup = ()=>{
            console.error(`${this.config.name} shutting down...`);
            this.performCleanup();
            process.exit(0);
        };
        process.once('SIGINT', cleanup);
        process.once('SIGTERM', cleanup);
        return {
            close: async ()=>{
                this.performCleanup();
            }
        };
    }
    async launchHttp(options) {
        if (!Number.isInteger(options.port) || options.port < 1 || options.port > 65535) throw new Error(`Invalid port number: ${options.port}. Port must be between 1 and 65535.`);
        await this.initializeToolsManager();
        const app = express();
        app.use(express.json({
            limit: '10mb'
        }));
        const sessions = new Map();
        app.all('/mcp', async (req, res)=>{
            const startTime = Date.now();
            const requestId = randomUUID().substring(0, 8);
            try {
                const rawSessionId = req.headers['mcp-session-id'];
                const sessionId = Array.isArray(rawSessionId) ? rawSessionId[0] : rawSessionId;
                let session = sessionId ? sessions.get(sessionId) : void 0;
                if (!session && 'POST' === req.method) {
                    if (sessions.size >= MAX_SESSIONS) {
                        console.error(`[${new Date().toISOString()}] [${requestId}] Session limit reached: ${sessions.size}/${MAX_SESSIONS}`);
                        res.status(503).json({
                            error: 'Too many active sessions',
                            message: 'Server is at maximum capacity. Please try again later.'
                        });
                        return;
                    }
                    session = await this.createHttpSession(sessions);
                    console.log(`[${new Date().toISOString()}] [${requestId}] New session created: ${session.transport.sessionId}`);
                }
                if (session) {
                    session.lastAccessedAt = new Date();
                    await session.transport.handleRequest(req, res, req.body);
                    const duration = Date.now() - startTime;
                    console.log(`[${new Date().toISOString()}] [${requestId}] Request completed in ${duration}ms`);
                } else {
                    console.error(`[${new Date().toISOString()}] [${requestId}] Invalid session or GET without session`);
                    res.status(400).json({
                        error: 'Invalid session or GET without session'
                    });
                }
            } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                const duration = Date.now() - startTime;
                console.error(`[${new Date().toISOString()}] [${requestId}] MCP request error after ${duration}ms: ${message}`);
                if (!res.headersSent) res.status(500).json({
                    error: 'Internal server error',
                    message: 'Failed to process MCP request'
                });
            }
        });
        const host = options.host || 'localhost';
        const server = app.listen(options.port, host, ()=>{
            console.log(`${this.config.name} HTTP server listening on http://${host}:${options.port}/mcp`);
        }).on('error', (error)=>{
            if ('EADDRINUSE' === error.code) console.error(`ERROR: Port ${options.port} is already in use.\nPlease try a different port: --port=<number>\nExample: --mode=http --port=${options.port + 1}`);
            else if ('EACCES' === error.code) console.error(`ERROR: Permission denied to bind to port ${options.port}.\nPorts below 1024 require root/admin privileges.\nPlease use a port above 1024 or run with elevated privileges.`);
            else console.error(`ERROR: Failed to start HTTP server on ${host}:${options.port}\nReason: ${error.message}\nCode: ${error.code || 'unknown'}`);
            process.exit(1);
        });
        const cleanupInterval = this.startSessionCleanup(sessions);
        this.setupHttpShutdownHandlers(server, sessions, cleanupInterval);
        return {
            port: options.port,
            host,
            close: async ()=>{
                clearInterval(cleanupInterval);
                for (const session of sessions.values())try {
                    await session.transport.close();
                } catch (error) {
                    const message = error instanceof Error ? error.message : String(error);
                    console.error(`Failed to close session ${session.transport.sessionId}: ${message}`);
                }
                sessions.clear();
                return new Promise((resolve)=>{
                    server.close((err)=>{
                        if (err) console.error('Error closing HTTP server:', err);
                        this.performCleanup();
                        resolve();
                    });
                });
            }
        };
    }
    async createHttpSession(sessions) {
        const transport = new StreamableHTTPServerTransport({
            sessionIdGenerator: ()=>randomUUID(),
            onsessioninitialized: (sid)=>{
                sessions.set(sid, {
                    transport,
                    createdAt: new Date(),
                    lastAccessedAt: new Date()
                });
                console.log(`[${new Date().toISOString()}] Session ${sid} initialized (total: ${sessions.size})`);
            }
        });
        transport.onclose = ()=>{
            if (transport.sessionId) {
                sessions.delete(transport.sessionId);
                console.log(`[${new Date().toISOString()}] Session ${transport.sessionId} closed (remaining: ${sessions.size})`);
            }
        };
        try {
            await this.mcpServer.connect(transport);
        } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            console.error(`[${new Date().toISOString()}] Failed to connect MCP transport: ${message}`);
            if (transport.sessionId) sessions.delete(transport.sessionId);
            throw new Error(`Failed to initialize MCP session: ${message}`);
        }
        return {
            transport,
            createdAt: new Date(),
            lastAccessedAt: new Date()
        };
    }
    startSessionCleanup(sessions) {
        return setInterval(()=>{
            const now = Date.now();
            for (const [sid, session] of sessions)if (now - session.lastAccessedAt.getTime() > SESSION_TIMEOUT_MS) try {
                session.transport.close();
                sessions.delete(sid);
                console.log(`[${new Date().toISOString()}] Session ${sid} cleaned up due to inactivity (remaining: ${sessions.size})`);
            } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                console.error(`[${new Date().toISOString()}] Failed to close session ${sid} during cleanup: ${message}`);
                sessions.delete(sid);
            }
        }, CLEANUP_INTERVAL_MS);
    }
    setupHttpShutdownHandlers(server, sessions, cleanupInterval) {
        const cleanup = ()=>{
            console.error(`${this.config.name} shutting down...`);
            clearInterval(cleanupInterval);
            for (const session of sessions.values())try {
                session.transport.close();
            } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                console.error(`Error closing session during shutdown: ${message}`);
            }
            sessions.clear();
            try {
                server.close(()=>{
                    this.performCleanup();
                    process.exit(0);
                });
                setTimeout(()=>{
                    console.error('Forcefully shutting down after timeout');
                    this.performCleanup();
                    process.exit(1);
                }, 5000);
            } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                console.error(`Error closing HTTP server: ${message}`);
                this.performCleanup();
                process.exit(1);
            }
        };
        process.once('SIGINT', cleanup);
        process.once('SIGTERM', cleanup);
    }
    getServer() {
        return this.mcpServer;
    }
    getToolsManager() {
        return this.toolsManager;
    }
    constructor(config, toolsManager){
        _define_property(this, "mcpServer", void 0);
        _define_property(this, "toolsManager", void 0);
        _define_property(this, "config", void 0);
        _define_property(this, "providedToolsManager", void 0);
        this.config = config;
        this.mcpServer = new McpServer({
            name: config.name,
            version: config.version,
            description: config.description
        });
        this.providedToolsManager = toolsManager;
    }
}
export { BaseMCPServer, CLI_ARGS_CONFIG, launchMCPServer };
