"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    generateToolsFromActionSpace: ()=>generateToolsFromActionSpace,
    generateCommonTools: ()=>generateCommonTools
});
const img_namespaceObject = require("@midscene/shared/img");
const external_zod_namespaceObject = require("zod");
const external_zod_schema_utils_js_namespaceObject = require("../zod-schema-utils.js");
function getErrorMessage(error) {
    return error instanceof Error ? error.message : String(error);
}
function describeActionForMCP(action) {
    const actionDesc = action.description || `Execute ${action.name} action`;
    if (!action.paramSchema) return `${action.name} action, ${actionDesc}`;
    const schema = action.paramSchema;
    const isZodObjectType = schema._def?.typeName === 'ZodObject';
    if (!isZodObjectType || !schema.shape) {
        const typeName = (0, external_zod_schema_utils_js_namespaceObject.getZodTypeName)(schema);
        const description = (0, external_zod_schema_utils_js_namespaceObject.getZodDescription)(schema);
        const paramDesc = description ? `${typeName} - ${description}` : typeName;
        return `${action.name} action, ${actionDesc}. Parameter: ${paramDesc}`;
    }
    const paramDescriptions = [];
    for (const [key, field] of Object.entries(schema.shape))if (field && 'object' == typeof field) {
        const isFieldOptional = 'function' == typeof field.isOptional && field.isOptional();
        const typeName = (0, external_zod_schema_utils_js_namespaceObject.getZodTypeName)(field);
        const description = (0, external_zod_schema_utils_js_namespaceObject.getZodDescription)(field);
        let paramStr = `${key}${isFieldOptional ? '?' : ''} (${typeName})`;
        if (description) paramStr += ` - ${description}`;
        paramDescriptions.push(paramStr);
    }
    if (0 === paramDescriptions.length) return `${action.name} action, ${actionDesc}`;
    return `${action.name} action, ${actionDesc}. Parameters: ${paramDescriptions.join('; ')}`;
}
function isZodOptional(value) {
    return '_def' in value && value._def?.typeName === 'ZodOptional';
}
function isZodObject(value) {
    return '_def' in value && value._def?.typeName === 'ZodObject' && 'shape' in value;
}
function unwrapOptional(value) {
    if (isZodOptional(value)) return {
        innerValue: value._def.innerType,
        isOptional: true
    };
    return {
        innerValue: value,
        isOptional: false
    };
}
function isLocateField(value) {
    if (!isZodObject(value)) return false;
    return 'prompt' in value.shape;
}
function makePromptOptional(value, wrapInOptional) {
    const newShape = {
        ...value.shape
    };
    newShape.prompt = value.shape.prompt.optional();
    let newSchema = external_zod_namespaceObject.z.object(newShape).passthrough();
    if (wrapInOptional) newSchema = newSchema.optional();
    return newSchema;
}
function transformSchemaField(key, value) {
    const { innerValue, isOptional } = unwrapOptional(value);
    if (isZodObject(innerValue) && isLocateField(innerValue)) return [
        key,
        makePromptOptional(innerValue, isOptional)
    ];
    return [
        key,
        value
    ];
}
function extractActionSchema(paramSchema) {
    if (!paramSchema) return {};
    const schema = paramSchema;
    if (!isZodObject(schema)) return schema;
    return Object.fromEntries(Object.entries(schema.shape).map(([key, value])=>transformSchemaField(key, value)));
}
function serializeArgsToDescription(args) {
    try {
        return Object.entries(args).map(([key, value])=>{
            if ('object' == typeof value && null !== value) try {
                return `${key}: ${JSON.stringify(value)}`;
            } catch  {
                return `${key}: [object]`;
            }
            return `${key}: "${value}"`;
        }).join(', ');
    } catch (error) {
        const errorMessage = getErrorMessage(error);
        console.error('Error serializing args:', errorMessage);
        return `[args serialization failed: ${errorMessage}]`;
    }
}
function buildActionInstruction(actionName, args) {
    const argsDescription = serializeArgsToDescription(args);
    return argsDescription ? `Use the action "${actionName}" with ${argsDescription}` : `Use the action "${actionName}"`;
}
async function captureScreenshotResult(agent, actionName) {
    try {
        const screenshot = await agent.page?.screenshotBase64();
        if (!screenshot) return {
            content: [
                {
                    type: 'text',
                    text: `Action "${actionName}" completed.`
                }
            ]
        };
        const { mimeType, body } = (0, img_namespaceObject.parseBase64)(screenshot);
        return {
            content: [
                {
                    type: 'text',
                    text: `Action "${actionName}" completed.`
                },
                {
                    type: 'image',
                    data: body,
                    mimeType
                }
            ]
        };
    } catch (error) {
        const errorMessage = getErrorMessage(error);
        console.error('Error capturing screenshot:', errorMessage);
        return {
            content: [
                {
                    type: 'text',
                    text: `Action "${actionName}" completed (screenshot unavailable: ${errorMessage})`
                }
            ]
        };
    }
}
function createErrorResult(message) {
    return {
        content: [
            {
                type: 'text',
                text: message
            }
        ],
        isError: true
    };
}
function generateToolsFromActionSpace(actionSpace, getAgent) {
    return actionSpace.map((action)=>{
        const schema = extractActionSchema(action.paramSchema);
        return {
            name: action.name,
            description: describeActionForMCP(action),
            schema,
            handler: async (args)=>{
                try {
                    const agent = await getAgent();
                    if (agent.aiAction) {
                        const instruction = buildActionInstruction(action.name, args);
                        try {
                            await agent.aiAction(instruction);
                        } catch (error) {
                            const errorMessage = getErrorMessage(error);
                            console.error(`Error executing action "${action.name}":`, errorMessage);
                            return createErrorResult(`Failed to execute action "${action.name}": ${errorMessage}`);
                        }
                    }
                    return await captureScreenshotResult(agent, action.name);
                } catch (error) {
                    const errorMessage = getErrorMessage(error);
                    console.error(`Error in handler for "${action.name}":`, errorMessage);
                    return createErrorResult(`Failed to get agent or execute action "${action.name}": ${errorMessage}`);
                }
            },
            autoDestroy: true
        };
    });
}
function generateCommonTools(getAgent) {
    return [
        {
            name: 'take_screenshot',
            description: 'Capture screenshot of current page/screen',
            schema: {},
            handler: async ()=>{
                try {
                    const agent = await getAgent();
                    const screenshot = await agent.page?.screenshotBase64();
                    if (!screenshot) return createErrorResult('Screenshot not available');
                    const { mimeType, body } = (0, img_namespaceObject.parseBase64)(screenshot);
                    return {
                        content: [
                            {
                                type: 'image',
                                data: body,
                                mimeType
                            }
                        ]
                    };
                } catch (error) {
                    const errorMessage = getErrorMessage(error);
                    console.error('Error taking screenshot:', errorMessage);
                    return createErrorResult(`Failed to capture screenshot: ${errorMessage}`);
                }
            },
            autoDestroy: true
        }
    ];
}
exports.generateCommonTools = __webpack_exports__.generateCommonTools;
exports.generateToolsFromActionSpace = __webpack_exports__.generateToolsFromActionSpace;
for(var __rspack_i in __webpack_exports__)if (-1 === [
    "generateCommonTools",
    "generateToolsFromActionSpace"
].indexOf(__rspack_i)) exports[__rspack_i] = __webpack_exports__[__rspack_i];
Object.defineProperty(exports, '__esModule', {
    value: true
});
