import type { BaseMCPServer } from './base-server';
import type { HttpLaunchOptions, LaunchMCPServerResult } from './base-server';
import type { IMidsceneTools } from './types';
export interface LaunchMCPServerOptions extends HttpLaunchOptions {
    /**
     * Whether to show server logs
     * @default true
     */
    verbose?: boolean;
}
/**
 * Generic agent type (avoid importing from @midscene/core to prevent circular deps)
 */
export interface GenericAgent<TDevice = any> {
    interface: TDevice;
    constructor: {
        name: string;
    };
}
/**
 * Additional information for logging server startup
 */
export interface StartupInfo {
    port?: number;
    host?: string;
}
export interface MCPServerLauncherConfig<AgentType extends GenericAgent = GenericAgent, ToolsManagerType extends IMidsceneTools = IMidsceneTools> {
    agent: AgentType;
    platformName: string;
    ToolsManagerClass: new (...args: any[]) => ToolsManagerType;
    MCPServerClass: new (toolsManager?: ToolsManagerType) => BaseMCPServer;
}
/**
 * Create a generic MCP server launcher for a given agent, tools manager, and MCP server.
 *
 * This helper centralizes the common wiring logic used by platform-specific launchers:
 * it constructs a tools manager, attaches the provided `agent` to it, then instantiates
 * the `MCPServerClass` and exposes convenience methods to start the server over stdio
 * (`launch`) or HTTP (`launchHttp`).
 *
 * Use this helper when adding a new platform-specific launcher or when you want to
 * avoid duplicating boilerplate code for starting an MCP server. Typically, callers
 * provide:
 * - an `agent` instance that contains the underlying device on its `interface` property
 * - a `ToolsManagerClass` that knows how to expose tools for that agent
 * - an `MCPServerClass` that implements the MCP protocol and supports `launch` and
 *   `launchHttp` methods.
 *
 * The returned object has two methods:
 * - `launch(options?)` to start the server using stdio transport
 * - `launchHttp(options)` to start the server using HTTP transport
 * Both methods accept a `verbose` flag to control console logging.
 *
 * @param config Configuration describing the agent, platform name (for logging),
 *               tools manager implementation, and MCP server implementation.
 *
 * @returns An object with `launch` and `launchHttp` methods to start the MCP server.
 *
 * @example
 * ```typescript
 * import { createMCPServerLauncher } from '@midscene/shared/mcp';
 * import { Agent } from '@midscene/core/agent';
 * import { WebMidsceneTools } from './web-tools';
 * import { WebMCPServer } from './server';
 *
 * const agent = new Agent();
 * const launcher = createMCPServerLauncher({
 *   agent,
 *   platformName: 'Web',
 *   ToolsManagerClass: WebMidsceneTools,
 *   MCPServerClass: WebMCPServer,
 * });
 *
 * // Start with stdio
 * await launcher.launch({ verbose: true });
 *
 * // Or start with HTTP
 * await launcher.launchHttp({ port: 3000, host: 'localhost' });
 * ```
 *
 * @internal
 */
export declare function createMCPServerLauncher<AgentType extends GenericAgent, ToolsManagerType extends IMidsceneTools>(config: MCPServerLauncherConfig<AgentType, ToolsManagerType>): {
    /**
     * Launch the MCP server with stdio transport
     */
    launch(options?: {
        verbose?: boolean;
    }): Promise<LaunchMCPServerResult>;
    /**
     * Launch the MCP server with HTTP transport
     */
    launchHttp(options: LaunchMCPServerOptions): Promise<LaunchMCPServerResult>;
};
