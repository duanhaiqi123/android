"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    mcpKitForAgent: ()=>mcpKitForAgent,
    IOSMCPServer: ()=>IOSMCPServer,
    mcpServerForAgent: ()=>mcpServerForAgent
});
const mcp_namespaceObject = require("@midscene/shared/mcp");
const agent_namespaceObject = require("@midscene/core/agent");
const logger_namespaceObject = require("@midscene/shared/logger");
const external_node_assert_namespaceObject = require("node:assert");
var external_node_assert_default = /*#__PURE__*/ __webpack_require__.n(external_node_assert_namespaceObject);
const core_namespaceObject = require("@midscene/core");
const device_namespaceObject = require("@midscene/core/device");
const utils_namespaceObject = require("@midscene/core/utils");
const constants_namespaceObject = require("@midscene/shared/constants");
const img_namespaceObject = require("@midscene/shared/img");
const webdriver_namespaceObject = require("@midscene/webdriver");
const debugIOS = (0, logger_namespaceObject.getDebug)('webdriver:ios');
class IOSWebDriverClient extends webdriver_namespaceObject.WebDriverClient {
    async launchApp(bundleId) {
        this.ensureSession();
        try {
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/apps/launch`, {
                bundleId
            });
            debugIOS(`Launched app: ${bundleId}`);
        } catch (error) {
            debugIOS(`Failed to launch app ${bundleId}: ${error}`);
            throw error;
        }
    }
    async activateApp(bundleId) {
        this.ensureSession();
        await this.makeRequest('POST', `/session/${this.sessionId}/wda/apps/activate`, {
            bundleId
        });
    }
    async terminateApp(bundleId) {
        this.ensureSession();
        await this.makeRequest('POST', `/session/${this.sessionId}/wda/apps/terminate`, {
            bundleId
        });
    }
    async openUrl(url) {
        this.ensureSession();
        try {
            await this.makeRequest('POST', `/session/${this.sessionId}/url`, {
                url
            });
        } catch (error) {
            debugIOS(`Direct URL opening failed, trying Safari fallback: ${error}`);
            await this.launchApp('com.apple.mobilesafari');
            await new Promise((resolve)=>setTimeout(resolve, 2000));
            await this.makeRequest('POST', `/session/${this.sessionId}/url`, {
                url
            });
        }
    }
    async pressHomeButton() {
        this.ensureSession();
        try {
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/pressButton`, {
                name: 'home'
            });
            debugIOS('Home button pressed using hardware key');
        } catch (error) {
            debugIOS(`Failed to press home button: ${error}`);
            throw new Error(`Failed to press home button: ${error}`);
        }
    }
    async appSwitcher() {
        this.ensureSession();
        try {
            const windowSize = await this.getWindowSize();
            debugIOS('Triggering app switcher with slow swipe up gesture');
            const centerX = windowSize.width / 2;
            const startY = windowSize.height - 5;
            const endY = 0.5 * windowSize.height;
            await this.swipe(centerX, startY, centerX, endY, 1500);
            await new Promise((resolve)=>setTimeout(resolve, 800));
        } catch (error) {
            debugIOS(`App switcher failed: ${error}`);
            throw new Error(`Failed to trigger app switcher: ${error}`);
        }
    }
    async pressKey(key) {
        this.ensureSession();
        debugIOS(`Attempting to press key: ${key}`);
        if ('Enter' === key || 'Return' === key || 'return' === key) {
            debugIOS('Handling Enter/Return key for iOS');
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/keys`, {
                value: [
                    '\n'
                ]
            });
            debugIOS('Sent newline character for Enter key');
            await new Promise((resolve)=>setTimeout(resolve, 100));
            return;
        }
        if ('Backspace' === key || 'Delete' === key) try {
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/keys`, {
                value: [
                    '\b'
                ]
            });
            debugIOS('Sent backspace character');
            return;
        } catch (error) {
            debugIOS(`Backspace failed: ${error}`);
        }
        if ('Space' === key) try {
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/keys`, {
                value: [
                    ' '
                ]
            });
            debugIOS('Sent space character');
            return;
        } catch (error) {
            debugIOS(`Space key failed: ${error}`);
        }
        const normalizedKey = this.normalizeKeyName(key);
        const iosKeyMap = {
            Tab: '\t',
            ArrowUp: '\uE013',
            ArrowDown: '\uE015',
            ArrowLeft: '\uE012',
            ArrowRight: '\uE014',
            Home: '\uE011',
            End: '\uE010'
        };
        if (iosKeyMap[normalizedKey]) try {
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/keys`, {
                value: [
                    iosKeyMap[normalizedKey]
                ]
            });
            debugIOS(`Sent WebDriver key code for: ${key}`);
            return;
        } catch (error) {
            debugIOS(`WebDriver key failed for "${key}": ${error}`);
        }
        if (1 === key.length) try {
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/keys`, {
                value: [
                    key
                ]
            });
            debugIOS(`Sent single character: "${key}"`);
            return;
        } catch (error) {
            debugIOS(`Failed to send character "${key}": ${error}`);
        }
        debugIOS(`Warning: Key "${key}" is not supported on iOS platform`);
        throw new Error(`Key "${key}" is not supported on iOS platform`);
    }
    async getActiveElement() {
        this.ensureSession();
        debugIOS('Getting active element');
        try {
            const response = await this.makeRequest('GET', `/session/${this.sessionId}/element/active`);
            const elementId = response.value?.ELEMENT || response.value?.['element-6066-11e4-a52e-4f735466cecf'] || response.ELEMENT || response['element-6066-11e4-a52e-4f735466cecf'];
            if (elementId) {
                debugIOS(`Got active element ID: ${elementId}`);
                return elementId;
            }
            debugIOS('No active element found');
            return null;
        } catch (error) {
            debugIOS(`Failed to get active element: ${error}`);
            return null;
        }
    }
    async clearElement(elementId) {
        this.ensureSession();
        debugIOS(`Clearing element: ${elementId}`);
        try {
            await this.makeRequest('POST', `/session/${this.sessionId}/element/${elementId}/clear`);
            debugIOS('Element cleared successfully');
        } catch (error) {
            debugIOS(`Failed to clear element: ${error}`);
            throw new Error(`Failed to clear element: ${error}`);
        }
    }
    async clearActiveElement() {
        try {
            const elementId = await this.getActiveElement();
            if (!elementId) {
                debugIOS('No active element to clear');
                return false;
            }
            await this.clearElement(elementId);
            return true;
        } catch (error) {
            debugIOS(`Failed to clear active element: ${error}`);
            return false;
        }
    }
    normalizeKeyName(key) {
        return key.charAt(0).toUpperCase() + key.slice(1).toLowerCase();
    }
    async dismissKeyboard(keyNames) {
        this.ensureSession();
        try {
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/keyboard/dismiss`, {
                keyNames: keyNames || [
                    'done'
                ]
            });
            debugIOS('Dismissed keyboard using WDA API');
            return true;
        } catch (error) {
            debugIOS(`Failed to dismiss keyboard: ${error}`);
            return false;
        }
    }
    async typeText(text) {
        this.ensureSession();
        try {
            const cleanText = text.trim();
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/keys`, {
                value: cleanText.split('')
            });
            debugIOS(`Typed text: "${text}"`);
        } catch (error) {
            debugIOS(`Failed to type text "${text}": ${error}`);
            throw new Error(`Failed to type text: ${error}`);
        }
    }
    async tap(x, y) {
        this.ensureSession();
        try {
            await this.makeRequest('POST', `/session/${this.sessionId}/wda/tap`, {
                x,
                y
            });
            debugIOS(`Tapped at coordinates (${x}, ${y})`);
        } catch (error) {
            debugIOS(`New tap endpoint failed, trying legacy endpoint: ${error}`);
            try {
                await this.makeRequest('POST', `/session/${this.sessionId}/wda/tap/0`, {
                    x,
                    y
                });
                debugIOS(`Tapped at coordinates (${x}, ${y}) using legacy endpoint`);
            } catch (fallbackError) {
                debugIOS(`Failed to tap at (${x}, ${y}): ${fallbackError}`);
                throw new Error(`Failed to tap at coordinates: ${fallbackError}`);
            }
        }
    }
    async swipe(fromX, fromY, toX, toY, duration = 500) {
        this.ensureSession();
        const actions = {
            actions: [
                {
                    type: 'pointer',
                    id: 'finger1',
                    parameters: {
                        pointerType: 'touch'
                    },
                    actions: [
                        {
                            type: 'pointerMove',
                            duration: 0,
                            x: fromX,
                            y: fromY
                        },
                        {
                            type: 'pointerDown',
                            button: 0
                        },
                        {
                            type: 'pause',
                            duration: 100
                        },
                        {
                            type: 'pointerMove',
                            duration,
                            x: toX,
                            y: toY
                        },
                        {
                            type: 'pointerUp',
                            button: 0
                        }
                    ]
                }
            ]
        };
        await this.makeRequest('POST', `/session/${this.sessionId}/actions`, actions);
        debugIOS(`Swiped using W3C Actions from (${fromX}, ${fromY}) to (${toX}, ${toY}) in ${duration}ms`);
    }
    async longPress(x, y, duration = 1000) {
        this.ensureSession();
        await this.makeRequest('POST', `/session/${this.sessionId}/wda/touchAndHold`, {
            x,
            y,
            duration: duration / 1000
        });
        debugIOS(`Long pressed at coordinates (${x}, ${y}) for ${duration}ms`);
    }
    async doubleTap(x, y) {
        this.ensureSession();
        await this.makeRequest('POST', `/session/${this.sessionId}/wda/doubleTap`, {
            x,
            y
        });
        debugIOS(`Double tapped at coordinates (${x}, ${y})`);
    }
    async tripleTap(x, y) {
        this.ensureSession();
        await this.makeRequest('POST', `/session/${this.sessionId}/wda/tapWithNumberOfTaps`, {
            x,
            y,
            numberOfTaps: 3,
            numberOfTouches: 1
        });
        debugIOS(`Triple tapped at coordinates (${x}, ${y})`);
    }
    async getScreenScale() {
        this.ensureSession();
        try {
            const screenResponse = await this.makeRequest('GET', `/session/${this.sessionId}/wda/screen`);
            if (screenResponse?.value?.scale) {
                debugIOS(`Got screen scale from WDA screen endpoint: ${screenResponse.value.scale}`);
                return screenResponse.value.scale;
            }
        } catch (error) {
            debugIOS(`Failed to get screen scale from /wda/screen: ${error}`);
        }
        try {
            debugIOS('Calculating screen scale from screenshot and window size');
            const [screenshotBase64, windowSize] = await Promise.all([
                this.takeScreenshot(),
                this.getWindowSize()
            ]);
            const { jimpFromBase64 } = await import("@midscene/shared/img");
            const screenshotImg = await jimpFromBase64(screenshotBase64);
            const screenshotWidth = screenshotImg.bitmap.width;
            const screenshotHeight = screenshotImg.bitmap.height;
            const scale = Math.max(screenshotWidth, screenshotHeight) / Math.max(windowSize.width, windowSize.height);
            const roundedScale = Math.round(scale);
            debugIOS(`Calculated screen scale: ${roundedScale} (screenshot: ${screenshotWidth}x${screenshotHeight}, window: ${windowSize.width}x${windowSize.height})`);
            return roundedScale;
        } catch (error) {
            debugIOS(`Failed to calculate screen scale: ${error}`);
        }
        debugIOS('No screen scale found');
        return null;
    }
    async createSession(capabilities) {
        const defaultCapabilities = {
            platformName: 'iOS',
            automationName: 'XCUITest',
            shouldUseSingletonTestManager: false,
            shouldUseTestManagerForVisibilityDetection: false,
            ...capabilities
        };
        const session = await super.createSession(defaultCapabilities);
        await this.setupIOSSession();
        return session;
    }
    async setupIOSSession() {
        if (!this.sessionId) return;
        try {
            await this.makeRequest('POST', `/session/${this.sessionId}/appium/settings`, {
                snapshotMaxDepth: 50,
                elementResponseAttributes: 'type,label,name,value,rect,enabled,visible'
            });
            debugIOS('iOS session configuration applied');
        } catch (error) {
            debugIOS(`Failed to apply iOS session configuration: ${error}`);
        }
    }
    async executeRequest(method, endpoint, data) {
        this.ensureSession();
        return this.makeRequest(method, endpoint, data);
    }
}
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const debugDevice = (0, logger_namespaceObject.getDebug)('ios:device');
const WDA_HTTP_METHODS = [
    'GET',
    'POST',
    'DELETE',
    'PUT'
];
class IOSDevice {
    actionSpace() {
        const defaultActions = [
            (0, device_namespaceObject.defineActionTap)(async (param)=>{
                const element = param.locate;
                external_node_assert_default()(element, 'Element not found, cannot tap');
                await this.mouseClick(element.center[0], element.center[1]);
            }),
            (0, device_namespaceObject.defineActionDoubleClick)(async (param)=>{
                const element = param.locate;
                external_node_assert_default()(element, 'Element not found, cannot double click');
                await this.doubleTap(element.center[0], element.center[1]);
            }),
            (0, device_namespaceObject.defineAction)({
                name: 'Input',
                description: 'Input text into the input field',
                interfaceAlias: 'aiInput',
                paramSchema: core_namespaceObject.z.object({
                    value: core_namespaceObject.z.string().describe('The text to input. Provide the final content for replace/append modes, or an empty string when using clear mode to remove existing text.'),
                    autoDismissKeyboard: core_namespaceObject.z.boolean().optional().describe('Whether to dismiss the keyboard after input. Defaults to true if not specified. Set to false to keep the keyboard visible after input.'),
                    mode: core_namespaceObject.z["enum"]([
                        'replace',
                        'clear',
                        'append'
                    ]).default('replace').optional().describe('Input mode: "replace" (default) - clear the field and input the value; "append" - append the value to existing content; "clear" - clear the field without inputting new text.'),
                    locate: (0, core_namespaceObject.getMidsceneLocationSchema)().describe('The input field to be filled').optional()
                }),
                call: async (param)=>{
                    const element = param.locate;
                    if (element) {
                        if ('append' !== param.mode) await this.clearInput(element);
                    }
                    if ('clear' === param.mode) return;
                    if (!param || !param.value) return;
                    const autoDismissKeyboard = param.autoDismissKeyboard ?? this.options?.autoDismissKeyboard;
                    await this.typeText(param.value, {
                        autoDismissKeyboard
                    });
                }
            }),
            (0, device_namespaceObject.defineActionScroll)(async (param)=>{
                const element = param.locate;
                const startingPoint = element ? {
                    left: element.center[0],
                    top: element.center[1]
                } : void 0;
                const scrollToEventName = param?.scrollType;
                if ('scrollToTop' === scrollToEventName) await this.scrollUntilTop(startingPoint);
                else if ('scrollToBottom' === scrollToEventName) await this.scrollUntilBottom(startingPoint);
                else if ('scrollToRight' === scrollToEventName) await this.scrollUntilRight(startingPoint);
                else if ('scrollToLeft' === scrollToEventName) await this.scrollUntilLeft(startingPoint);
                else if ('singleAction' !== scrollToEventName && scrollToEventName) throw new Error(`Unknown scroll event type: ${scrollToEventName}, param: ${JSON.stringify(param)}`);
                else {
                    if (param?.direction !== 'down' && param && param.direction) if ('up' === param.direction) await this.scrollUp(param.distance || void 0, startingPoint);
                    else if ('left' === param.direction) await this.scrollLeft(param.distance || void 0, startingPoint);
                    else if ('right' === param.direction) await this.scrollRight(param.distance || void 0, startingPoint);
                    else throw new Error(`Unknown scroll direction: ${param.direction}`);
                    else await this.scrollDown(param?.distance || void 0, startingPoint);
                    await (0, utils_namespaceObject.sleep)(500);
                }
            }),
            (0, device_namespaceObject.defineActionDragAndDrop)(async (param)=>{
                const from = param.from;
                const to = param.to;
                external_node_assert_default()(from, 'missing "from" param for drag and drop');
                external_node_assert_default()(to, 'missing "to" param for drag and drop');
                await this.swipe(from.center[0], from.center[1], to.center[0], to.center[1]);
            }),
            (0, device_namespaceObject.defineActionKeyboardPress)(async (param)=>{
                await this.pressKey(param.keyName);
            }),
            (0, device_namespaceObject.defineAction)({
                name: 'IOSLongPress',
                description: 'Trigger a long press on the screen at specified coordinates on iOS devices',
                paramSchema: core_namespaceObject.z.object({
                    duration: core_namespaceObject.z.number().optional().describe('The duration of the long press in milliseconds'),
                    locate: (0, core_namespaceObject.getMidsceneLocationSchema)().describe('The element to be long pressed')
                }),
                call: async (param)=>{
                    const element = param.locate;
                    external_node_assert_default()(element, 'IOSLongPress requires an element to be located');
                    const [x, y] = element.center;
                    await this.longPress(x, y, param?.duration);
                }
            }),
            (0, device_namespaceObject.defineActionClearInput)(async (param)=>{
                const element = param.locate;
                external_node_assert_default()(element, 'Element not found, cannot clear input');
                await this.clearInput(element);
            })
        ];
        const platformSpecificActions = Object.values(createPlatformActions(this));
        const customActions = this.customActions || [];
        return [
            ...defaultActions,
            ...platformSpecificActions,
            ...customActions
        ];
    }
    describe() {
        return this.description || `Device ID: ${this.deviceId}`;
    }
    async getConnectedDeviceInfo() {
        return await this.wdaBackend.getDeviceInfo();
    }
    async connect() {
        external_node_assert_default()(!this.destroyed, `IOSDevice ${this.deviceId} has been destroyed and cannot execute commands`);
        debugDevice(`Connecting to iOS device: ${this.deviceId}`);
        try {
            await this.wdaManager.start();
            await this.wdaBackend.createSession();
            const deviceInfo = await this.wdaBackend.getDeviceInfo();
            if (deviceInfo?.udid) {
                this.deviceId = deviceInfo.udid;
                debugDevice(`Updated device ID to real UDID: ${this.deviceId}`);
            }
            const size = await this.getScreenSize();
            this.description = `
UDID: ${this.deviceId}${deviceInfo ? `
Name: ${deviceInfo.name}
Model: ${deviceInfo.model}` : ''}
Type: WebDriverAgent
ScreenSize: ${size.width}x${size.height} (DPR: ${size.scale})
`;
            debugDevice('iOS device connected successfully', this.description);
        } catch (e) {
            debugDevice(`Failed to connect to iOS device: ${e}`);
            throw new Error(`Unable to connect to iOS device ${this.deviceId}: ${e}`);
        }
    }
    async launch(uri) {
        this.uri = uri;
        try {
            debugDevice(`Launching app: ${uri}`);
            if (uri.startsWith('http://') || uri.startsWith('https://') || uri.includes('://')) await this.openUrl(uri);
            else await this.wdaBackend.launchApp(uri);
            debugDevice(`Successfully launched: ${uri}`);
        } catch (error) {
            debugDevice(`Error launching ${uri}: ${error}`);
            throw new Error(`Failed to launch ${uri}: ${error.message}`);
        }
        return this;
    }
    async getElementsInfo() {
        return [];
    }
    async getElementsNodeTree() {
        return {
            node: null,
            children: []
        };
    }
    async initializeDevicePixelRatio() {
        if (this.devicePixelRatioInitialized) return;
        const apiScale = await this.wdaBackend.getScreenScale();
        external_node_assert_default()(apiScale && apiScale > 0, 'Failed to get device pixel ratio from WebDriverAgent API');
        debugDevice(`Got screen scale from WebDriverAgent API: ${apiScale}`);
        this.devicePixelRatio = apiScale;
        this.devicePixelRatioInitialized = true;
    }
    async getScreenSize() {
        await this.initializeDevicePixelRatio();
        const windowSize = await this.wdaBackend.getWindowSize();
        return {
            width: windowSize.width,
            height: windowSize.height,
            scale: this.devicePixelRatio
        };
    }
    async size() {
        const screenSize = await this.getScreenSize();
        return {
            width: screenSize.width,
            height: screenSize.height,
            dpr: screenSize.scale
        };
    }
    async screenshotBase64() {
        debugDevice('Taking screenshot via WDA');
        try {
            const base64Data = await this.wdaBackend.takeScreenshot();
            const result = (0, img_namespaceObject.createImgBase64ByFormat)('png', base64Data);
            debugDevice('Screenshot taken successfully');
            return result;
        } catch (error) {
            debugDevice(`Screenshot failed: ${error}`);
            throw new Error(`Failed to take screenshot: ${error}`);
        }
    }
    async clearInput(element) {
        if (!element) return;
        await this.tap(element.center[0], element.center[1]);
        await (0, utils_namespaceObject.sleep)(100);
        debugDevice('Attempting to clear input with WebDriver Clear API');
        const cleared = await this.wdaBackend.clearActiveElement();
        cleared ? debugDevice('Successfully cleared input with WebDriver Clear API') : debugDevice('WebDriver Clear API returned false (no active element or clear failed)');
    }
    async url() {
        return '';
    }
    async tap(x, y) {
        await this.wdaBackend.tap(Math.round(x), Math.round(y));
    }
    async mouseClick(x, y) {
        debugDevice(`mouseClick at coordinates (${x}, ${y})`);
        await this.tap(x, y);
    }
    async doubleTap(x, y) {
        await this.wdaBackend.doubleTap(Math.round(x), Math.round(y));
    }
    async tripleTap(x, y) {
        await this.wdaBackend.tripleTap(Math.round(x), Math.round(y));
    }
    async longPress(x, y, duration = 1000) {
        await this.wdaBackend.longPress(Math.round(x), Math.round(y), duration);
    }
    async swipe(fromX, fromY, toX, toY, duration = 500) {
        await this.wdaBackend.swipe(Math.round(fromX), Math.round(fromY), Math.round(toX), Math.round(toY), duration);
    }
    async typeText(text, options) {
        if (!text) return;
        const shouldAutoDismissKeyboard = options?.autoDismissKeyboard ?? this.options?.autoDismissKeyboard ?? true;
        debugDevice(`Typing text: "${text}"`);
        try {
            await (0, utils_namespaceObject.sleep)(200);
            await this.wdaBackend.typeText(text);
            await (0, utils_namespaceObject.sleep)(300);
        } catch (error) {
            debugDevice(`Failed to type text with WDA: ${error}`);
            throw error;
        }
        if (shouldAutoDismissKeyboard) await this.hideKeyboard();
    }
    async pressKey(key) {
        await this.wdaBackend.pressKey(key);
    }
    async scrollUp(distance, startPoint) {
        const { width, height } = await this.size();
        const start = startPoint ? {
            x: Math.round(startPoint.left),
            y: Math.round(startPoint.top)
        } : {
            x: Math.round(width / 2),
            y: Math.round(height / 2)
        };
        const scrollDistance = Math.round(distance || height / 3);
        await this.swipe(start.x, start.y, start.x, start.y + scrollDistance);
    }
    async scrollDown(distance, startPoint) {
        const { width, height } = await this.size();
        const start = startPoint ? {
            x: Math.round(startPoint.left),
            y: Math.round(startPoint.top)
        } : {
            x: Math.round(width / 2),
            y: Math.round(height / 2)
        };
        const scrollDistance = Math.round(distance || height / 3);
        await this.swipe(start.x, start.y, start.x, start.y - scrollDistance);
    }
    async scrollLeft(distance, startPoint) {
        const { width, height } = await this.size();
        const start = startPoint ? {
            x: Math.round(startPoint.left),
            y: Math.round(startPoint.top)
        } : {
            x: Math.round(width / 2),
            y: Math.round(height / 2)
        };
        const scrollDistance = Math.round(distance || 0.7 * width);
        await this.swipe(start.x, start.y, start.x + scrollDistance, start.y);
    }
    async scrollRight(distance, startPoint) {
        const { width, height } = await this.size();
        const start = startPoint ? {
            x: Math.round(startPoint.left),
            y: Math.round(startPoint.top)
        } : {
            x: Math.round(width / 2),
            y: Math.round(height / 2)
        };
        const scrollDistance = Math.round(distance || 0.7 * width);
        await this.swipe(start.x, start.y, start.x - scrollDistance, start.y);
    }
    async scrollUntilTop(startPoint) {
        debugDevice('Using screenshot-based scroll detection for better reliability');
        await this.scrollUntilBoundary('up', startPoint, 1);
    }
    async scrollUntilBottom(startPoint) {
        debugDevice('Using screenshot-based scroll detection for better reliability');
        await this.scrollUntilBoundary('down', startPoint, 1);
    }
    compareScreenshots(screenshot1, screenshot2, tolerancePercent = 2) {
        if (screenshot1 === screenshot2) {
            debugDevice('Screenshots are identical');
            return true;
        }
        const len1 = screenshot1.length;
        const len2 = screenshot2.length;
        debugDevice(`Screenshots differ: length1=${len1}, length2=${len2}`);
        if (Math.abs(len1 - len2) > 0.1 * Math.min(len1, len2)) {
            debugDevice('Screenshots have significant length difference');
            return false;
        }
        if (len1 > 0 && len2 > 0) {
            const minLength = Math.min(len1, len2);
            const sampleSize = Math.min(2000, minLength);
            let diffCount = 0;
            for(let i = 0; i < sampleSize; i++)if (screenshot1[i] !== screenshot2[i]) diffCount++;
            const diffPercent = diffCount / sampleSize * 100;
            debugDevice(`Character differences: ${diffCount}/${sampleSize} (${diffPercent.toFixed(2)}%)`);
            const isSimilar = diffPercent <= tolerancePercent;
            if (isSimilar) debugDevice(`Screenshots are similar enough (${diffPercent.toFixed(2)}% <= ${tolerancePercent}%)`);
            return isSimilar;
        }
        return false;
    }
    async scrollUntilBoundary(direction, startPoint, maxUnchangedCount = 1) {
        const maxAttempts = 20;
        const { width, height } = await this.size();
        let start;
        if (startPoint) start = {
            x: Math.round(startPoint.left),
            y: Math.round(startPoint.top)
        };
        else switch(direction){
            case 'up':
                start = {
                    x: Math.round(width / 2),
                    y: Math.round(0.2 * height)
                };
                break;
            case 'down':
                start = {
                    x: Math.round(width / 2),
                    y: Math.round(0.8 * height)
                };
                break;
            case 'left':
                start = {
                    x: Math.round(0.8 * width),
                    y: Math.round(height / 2)
                };
                break;
            case 'right':
                start = {
                    x: Math.round(0.2 * width),
                    y: Math.round(height / 2)
                };
                break;
        }
        let lastScreenshot = null;
        let unchangedCount = 0;
        debugDevice(`Starting scroll to ${direction} with content detection`);
        for(let i = 0; i < maxAttempts; i++)try {
            debugDevice(`Scroll attempt ${i + 1}/${maxAttempts}`);
            await (0, utils_namespaceObject.sleep)(500);
            const currentScreenshot = await this.screenshotBase64();
            if (lastScreenshot && this.compareScreenshots(lastScreenshot, currentScreenshot, 10)) {
                unchangedCount++;
                debugDevice(`Screen content unchanged (${unchangedCount}/${maxUnchangedCount})`);
                if (unchangedCount >= maxUnchangedCount) {
                    debugDevice(`Reached ${direction}: screen content no longer changes`);
                    break;
                }
            } else {
                if (lastScreenshot) debugDevice(`Content changed, resetting counter (was ${unchangedCount})`);
                unchangedCount = 0;
            }
            if (i >= 15 && 0 === unchangedCount) {
                debugDevice(`Too many attempts with dynamic content, stopping scroll to ${direction}`);
                break;
            }
            lastScreenshot = currentScreenshot;
            const scrollDistance = Math.round('left' === direction || 'right' === direction ? 0.6 * width : 0.6 * height);
            debugDevice(`Performing scroll: ${direction}, distance: ${scrollDistance}`);
            switch(direction){
                case 'up':
                    await this.swipe(start.x, start.y, start.x, start.y + scrollDistance, 300);
                    break;
                case 'down':
                    await this.swipe(start.x, start.y, start.x, start.y - scrollDistance, 300);
                    break;
                case 'left':
                    await this.swipe(start.x, start.y, start.x + scrollDistance, start.y, 300);
                    break;
                case 'right':
                    await this.swipe(start.x, start.y, start.x - scrollDistance, start.y, 300);
                    break;
            }
            debugDevice('Waiting for scroll and inertia to complete...');
            await (0, utils_namespaceObject.sleep)(2000);
        } catch (error) {
            debugDevice(`Error during scroll attempt ${i + 1}: ${error}`);
            await (0, utils_namespaceObject.sleep)(300);
        }
        debugDevice(`Scroll to ${direction} completed after ${maxAttempts} attempts`);
    }
    async scrollUntilLeft(startPoint) {
        await this.scrollUntilBoundary('left', startPoint, 1);
    }
    async scrollUntilRight(startPoint) {
        await this.scrollUntilBoundary('right', startPoint, 3);
    }
    async home() {
        await this.wdaBackend.pressHomeButton();
    }
    async appSwitcher() {
        try {
            debugDevice('Triggering app switcher with slow swipe up gesture');
            const { width, height } = await this.size();
            const centerX = Math.round(width / 2);
            const startY = Math.round(height - 5);
            const endY = Math.round(0.5 * height);
            await this.wdaBackend.swipe(centerX, startY, centerX, endY, 1500);
            await (0, utils_namespaceObject.sleep)(800);
        } catch (error) {
            debugDevice(`App switcher failed: ${error}`);
            throw new Error(`Failed to trigger app switcher: ${error}`);
        }
    }
    async hideKeyboard(keyNames) {
        try {
            const dismissKeys = keyNames && keyNames.length > 0 ? keyNames : [
                'return',
                'done',
                'go',
                'search',
                'next',
                'send'
            ];
            debugDevice(`Attempting to dismiss keyboard using WDA API with keys: ${dismissKeys.join(', ')}`);
            try {
                await this.wdaBackend.dismissKeyboard(dismissKeys);
                debugDevice('Successfully dismissed keyboard using WDA API');
                await (0, utils_namespaceObject.sleep)(500);
                return true;
            } catch (wdaError) {
                debugDevice(`WDA dismissKeyboard failed, falling back to swipe gesture: ${wdaError}`);
            }
            const windowSize = await this.wdaBackend.getWindowSize();
            const centerX = Math.round(windowSize.width / 2);
            const startY = Math.round(0.9 * windowSize.height);
            const endY = Math.round(0.5 * windowSize.height);
            await this.swipe(centerX, startY, centerX, endY, 300);
            debugDevice('Dismissed keyboard with swipe up gesture from bottom of screen');
            await (0, utils_namespaceObject.sleep)(500);
            return true;
        } catch (error) {
            debugDevice(`Failed to hide keyboard: ${error}`);
            return false;
        }
    }
    async openUrl(url, options) {
        const opts = {
            useSafariAsBackup: true,
            waitTime: 2000,
            ...options
        };
        try {
            debugDevice(`Opening URL: ${url}`);
            await this.wdaBackend.openUrl(url);
            await (0, utils_namespaceObject.sleep)(opts.waitTime);
            debugDevice(`Successfully opened URL: ${url}`);
        } catch (error) {
            debugDevice(`Direct URL opening failed: ${error}`);
            if (opts.useSafariAsBackup) {
                debugDevice(`Attempting to open URL via Safari: ${url}`);
                await this.openUrlViaSafari(url);
            } else throw new Error(`Failed to open URL: ${error}`);
        }
    }
    async openUrlViaSafari(url) {
        try {
            debugDevice(`Opening URL via Safari: ${url}`);
            await this.wdaBackend.terminateApp('com.apple.mobilesafari');
            await this.wdaBackend.launchApp('com.apple.mobilesafari');
            await (0, utils_namespaceObject.sleep)(2000);
            await this.typeText(url);
            await (0, utils_namespaceObject.sleep)(500);
            await this.pressKey('Return');
            await (0, utils_namespaceObject.sleep)(1000);
            try {
                await (0, utils_namespaceObject.sleep)(2000);
                debugDevice(`URL opened via Safari: ${url}`);
            } catch (dialogError) {
                debugDevice(`No confirmation dialog or dialog handling failed: ${dialogError}`);
            }
        } catch (error) {
            debugDevice(`Failed to open URL via Safari: ${error}`);
            throw new Error(`Failed to open URL via Safari: ${error}`);
        }
    }
    async runWdaRequest(method, endpoint, data) {
        return await this.wdaBackend.executeRequest(method, endpoint, data);
    }
    async destroy() {
        if (this.destroyed) return;
        try {
            await this.wdaBackend.deleteSession();
            await this.wdaManager.stop();
        } catch (error) {
            debugDevice(`Error during cleanup: ${error}`);
        }
        this.destroyed = true;
        debugDevice(`iOS device ${this.deviceId} destroyed`);
    }
    constructor(options){
        _define_property(this, "deviceId", void 0);
        _define_property(this, "devicePixelRatio", 1);
        _define_property(this, "devicePixelRatioInitialized", false);
        _define_property(this, "destroyed", false);
        _define_property(this, "description", void 0);
        _define_property(this, "customActions", void 0);
        _define_property(this, "wdaBackend", void 0);
        _define_property(this, "wdaManager", void 0);
        _define_property(this, "interfaceType", 'ios');
        _define_property(this, "uri", void 0);
        _define_property(this, "options", void 0);
        this.deviceId = 'pending-connection';
        this.options = options;
        this.customActions = options?.customActions;
        const wdaPort = options?.wdaPort || constants_namespaceObject.DEFAULT_WDA_PORT;
        const wdaHost = options?.wdaHost || 'localhost';
        this.wdaBackend = new IOSWebDriverClient({
            port: wdaPort,
            host: wdaHost
        });
        this.wdaManager = webdriver_namespaceObject.WDAManager.getInstance(wdaPort, wdaHost);
    }
}
const runWdaRequestParamSchema = core_namespaceObject.z.object({
    method: core_namespaceObject.z["enum"](WDA_HTTP_METHODS).describe('HTTP method (GET, POST, DELETE, PUT)'),
    endpoint: core_namespaceObject.z.string().describe('WebDriver API endpoint'),
    data: core_namespaceObject.z.object({}).passthrough().optional().describe('Optional request body data as JSON object')
});
const launchParamSchema = core_namespaceObject.z.string().describe('App bundle ID or URL to launch');
const createPlatformActions = (device)=>({
        RunWdaRequest: (0, device_namespaceObject.defineAction)({
            name: 'RunWdaRequest',
            description: 'Execute WebDriverAgent API request directly on iOS device',
            interfaceAlias: 'runWdaRequest',
            paramSchema: runWdaRequestParamSchema,
            call: async (param)=>await device.runWdaRequest(param.method, param.endpoint, param.data)
        }),
        Launch: (0, device_namespaceObject.defineAction)({
            name: 'Launch',
            description: 'Launch an iOS app or URL',
            interfaceAlias: 'launch',
            paramSchema: launchParamSchema,
            call: async (param)=>{
                await device.launch(param);
            }
        }),
        IOSHomeButton: (0, device_namespaceObject.defineAction)({
            name: 'IOSHomeButton',
            description: 'Trigger the system "home" operation on iOS devices',
            call: async ()=>{
                await device.home();
            }
        }),
        IOSAppSwitcher: (0, device_namespaceObject.defineAction)({
            name: 'IOSAppSwitcher',
            description: 'Trigger the system "app switcher" operation on iOS devices',
            call: async ()=>{
                await device.appSwitcher();
            }
        })
    });
const external_node_child_process_namespaceObject = require("node:child_process");
const external_node_os_namespaceObject = require("node:os");
const external_node_util_namespaceObject = require("node:util");
const execAsync = (0, external_node_util_namespaceObject.promisify)(external_node_child_process_namespaceObject.exec);
const debugUtils = (0, logger_namespaceObject.getDebug)('ios:utils');
function checkMacOSPlatform() {
    const currentPlatform = (0, external_node_os_namespaceObject.platform)();
    return {
        isMacOS: 'darwin' === currentPlatform,
        platform: currentPlatform
    };
}
async function checkIOSEnvironment() {
    try {
        const platformCheck = checkMacOSPlatform();
        if (!platformCheck.isMacOS) return {
            available: false,
            error: `iOS development is only supported on macOS. Current platform: ${platformCheck.platform}`
        };
        const { stdout: xcrunPath } = await execAsync('which xcrun');
        if (!xcrunPath.trim()) return {
            available: false,
            error: 'xcrun not found. Please install Xcode Command Line Tools: xcode-select --install'
        };
        try {
            await execAsync('xcodebuild -version');
        } catch (error) {
            return {
                available: false,
                error: 'xcodebuild not found. Please install Xcode from the App Store'
            };
        }
        debugUtils('iOS environment is available for WebDriverAgent');
        return {
            available: true
        };
    } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        debugUtils(`iOS environment not available: ${errorMsg}`);
        if (errorMsg.includes('xcrun')) return {
            available: false,
            error: 'Xcode Command Line Tools not properly configured. Please run: sudo xcode-select --reset'
        };
        return {
            available: false,
            error: `iOS development environment not available: ${errorMsg}`
        };
    }
}
function agent_define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const debugAgent = (0, logger_namespaceObject.getDebug)('ios:agent');
class IOSAgent extends agent_namespaceObject.Agent {
    createActionWrapper(name) {
        const action = this.wrapActionInActionSpace(name);
        return (...args)=>action(args[0]);
    }
    constructor(device, opts){
        super(device, opts), agent_define_property(this, "launch", void 0), agent_define_property(this, "runWdaRequest", void 0), agent_define_property(this, "home", void 0), agent_define_property(this, "appSwitcher", void 0);
        this.launch = this.createActionWrapper('Launch');
        this.runWdaRequest = this.createActionWrapper('RunWdaRequest');
        this.home = this.createActionWrapper('IOSHomeButton');
        this.appSwitcher = this.createActionWrapper('IOSAppSwitcher');
    }
}
async function agentFromWebDriverAgent(opts) {
    debugAgent('Creating iOS agent with WebDriverAgent auto-detection');
    const envCheck = await checkIOSEnvironment();
    if (!envCheck.available) throw new Error(`iOS environment not available: ${envCheck.error}`);
    const device = new IOSDevice(opts || {});
    await device.connect();
    return new IOSAgent(device, opts);
}
const debug = (0, logger_namespaceObject.getDebug)('mcp:ios-tools');
class IOSMidsceneTools extends mcp_namespaceObject.BaseMidsceneTools {
    createTemporaryDevice() {
        return new IOSDevice({});
    }
    async ensureAgent() {
        if (this.agent) return this.agent;
        debug('Creating iOS agent with WebDriverAgent');
        this.agent = await agentFromWebDriverAgent({
            autoDismissKeyboard: false
        });
        return this.agent;
    }
    preparePlatformTools() {
        return [
            {
                name: 'ios_connect',
                description: 'Connect to iOS device or simulator via WebDriverAgent',
                schema: {},
                handler: async ()=>{
                    const agent = await this.ensureAgent();
                    const screenshot = await agent.page.screenshotBase64();
                    return {
                        content: [
                            {
                                type: 'text',
                                text: 'Connected to iOS device'
                            },
                            ...this.buildScreenshotContent(screenshot)
                        ],
                        isError: false
                    };
                },
                autoDestroy: false
            }
        ];
    }
}
class IOSMCPServer extends mcp_namespaceObject.BaseMCPServer {
    createToolsManager() {
        return new IOSMidsceneTools();
    }
    constructor(toolsManager){
        super({
            name: '@midscene/ios-mcp',
            version: "1.2.0",
            description: 'Control the iOS device using natural language commands'
        }, toolsManager);
    }
}
function mcpServerForAgent(agent) {
    return (0, mcp_namespaceObject.createMCPServerLauncher)({
        agent,
        platformName: 'iOS',
        ToolsManagerClass: IOSMidsceneTools,
        MCPServerClass: IOSMCPServer
    });
}
async function mcpKitForAgent(agent) {
    const toolsManager = new IOSMidsceneTools();
    const iosAgent = agent instanceof IOSAgent ? agent : agent;
    toolsManager.setAgent(iosAgent);
    await toolsManager.initTools();
    return {
        description: 'Midscene MCP Kit for iOS automation',
        tools: toolsManager.getToolDefinitions()
    };
}
exports.IOSMCPServer = __webpack_exports__.IOSMCPServer;
exports.mcpKitForAgent = __webpack_exports__.mcpKitForAgent;
exports.mcpServerForAgent = __webpack_exports__.mcpServerForAgent;
for(var __rspack_i in __webpack_exports__)if (-1 === [
    "IOSMCPServer",
    "mcpKitForAgent",
    "mcpServerForAgent"
].indexOf(__rspack_i)) exports[__rspack_i] = __webpack_exports__[__rspack_i];
Object.defineProperty(exports, '__esModule', {
    value: true
});
