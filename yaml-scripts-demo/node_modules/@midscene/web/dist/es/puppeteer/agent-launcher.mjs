import { readFileSync } from "node:fs";
import { getDebug } from "@midscene/shared/logger";
import { assert } from "@midscene/shared/utils";
import { PuppeteerAgent } from "./index.mjs";
import { DEFAULT_WAIT_FOR_NETWORK_IDLE_TIMEOUT } from "@midscene/shared/constants";
import puppeteer from "puppeteer";
const defaultUA = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36';
const defaultViewportWidth = 1440;
const defaultViewportHeight = 768;
const defaultViewportScale = 'darwin' === process.platform ? 2 : 1;
const defaultWaitForNetworkIdleTimeout = DEFAULT_WAIT_FOR_NETWORK_IDLE_TIMEOUT;
function resolveAiActionContext(target, preference) {
    const data = preference?.aiActContext ?? preference?.aiActionContext ?? target.aiActionContext;
    return data;
}
const DANGEROUS_ARGS = [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-web-security',
    '--ignore-certificate-errors',
    '--disable-features=IsolateOrigins',
    '--disable-site-isolation-trials',
    '--allow-running-insecure-content'
];
function validateChromeArgs(args, baseArgs) {
    const newArgs = args.filter((arg)=>!baseArgs.some((baseArg)=>{
            const argFlag = arg.split('=')[0];
            const baseFlag = baseArg.split('=')[0];
            return argFlag === baseFlag;
        }));
    const dangerousArgs = newArgs.filter((arg)=>DANGEROUS_ARGS.some((dangerous)=>arg.startsWith(dangerous)));
    if (dangerousArgs.length > 0) console.warn(`Warning: Dangerous Chrome arguments detected: ${dangerousArgs.join(', ')}.\nThese arguments may reduce browser security. Use only in controlled testing environments.`);
}
const launcherDebug = getDebug('puppeteer:launcher');
async function launchPuppeteerPage(target, preference, browser) {
    assert(target.url, 'url is required');
    const freeFn = [];
    const ua = target.userAgent || defaultUA;
    let width = defaultViewportWidth;
    if (target.viewportWidth) {
        assert('number' == typeof target.viewportWidth, 'viewportWidth must be a number');
        width = Number.parseInt(target.viewportWidth, 10);
        assert(width > 0, `viewportWidth must be greater than 0, but got ${width}`);
    }
    let height = defaultViewportHeight;
    if (target.viewportHeight) {
        assert('number' == typeof target.viewportHeight, 'viewportHeight must be a number');
        height = Number.parseInt(target.viewportHeight, 10);
        assert(height > 0, `viewportHeight must be greater than 0, but got ${height}`);
    }
    let dpr = defaultViewportScale;
    if (target.viewportScale) {
        assert('number' == typeof target.viewportScale, 'viewportScale must be a number');
        dpr = Number.parseInt(target.viewportScale, 10);
        assert(dpr > 0, `viewportScale must be greater than 0, but got ${dpr}`);
    }
    const viewportConfig = {
        width,
        height,
        deviceScaleFactor: dpr
    };
    const headed = preference?.headed || preference?.keepWindow;
    const windowSizeArg = `--window-size=${width},${height + (headed ? 100 : 0)}`;
    const defaultViewportConfig = headed ? null : viewportConfig;
    if (headed && '1' === process.env.CI) console.warn('you are probably running headed mode in CI, this will usually fail.');
    const isWindows = 'win32' === process.platform;
    const baseArgs = [
        ...isWindows ? [] : [
            '--no-sandbox',
            '--disable-setuid-sandbox'
        ],
        '--disable-features=HttpsFirstBalancedModeAutoEnable',
        '--disable-features=PasswordLeakDetection',
        '--disable-save-password-bubble',
        `--user-agent="${ua}"`,
        windowSizeArg
    ];
    let args = baseArgs;
    if (target.chromeArgs && target.chromeArgs.length > 0) {
        validateChromeArgs(target.chromeArgs, baseArgs);
        args = [
            ...baseArgs,
            ...target.chromeArgs
        ];
        launcherDebug('Merging custom Chrome arguments', target.chromeArgs, 'Final args', args);
    }
    launcherDebug('launching browser with viewport, headed', headed, 'viewport', viewportConfig, 'args', args, 'preference', preference);
    let browserInstance = browser;
    if (!browserInstance) {
        browserInstance = await puppeteer.launch({
            headless: !preference?.headed,
            defaultViewport: defaultViewportConfig,
            args,
            acceptInsecureCerts: target.acceptInsecureCerts
        });
        freeFn.push({
            name: 'puppeteer_browser',
            fn: ()=>{
                if (!preference?.keepWindow) if (isWindows) setTimeout(()=>{
                    browserInstance?.close();
                }, 800);
                else browserInstance?.close();
            }
        });
    }
    const page = await browserInstance.newPage();
    if (target.cookie) {
        const cookieFileContent = readFileSync(target.cookie, 'utf-8');
        await browserInstance.setCookie(...JSON.parse(cookieFileContent));
    }
    if (ua) await page.setUserAgent(ua);
    if (viewportConfig) await page.setViewport(viewportConfig);
    const waitForNetworkIdleTimeout = 'number' == typeof target.waitForNetworkIdle?.timeout ? target.waitForNetworkIdle.timeout : defaultWaitForNetworkIdleTimeout;
    try {
        launcherDebug('goto', target.url);
        await page.goto(target.url);
        if (waitForNetworkIdleTimeout > 0) {
            launcherDebug('waitForNetworkIdle', waitForNetworkIdleTimeout);
            await page.waitForNetworkIdle({
                timeout: waitForNetworkIdleTimeout
            });
        }
    } catch (e) {
        if ('boolean' == typeof target.waitForNetworkIdle?.continueOnNetworkIdleError && !target.waitForNetworkIdle?.continueOnNetworkIdleError) {
            const newError = new Error(`failed to wait for network idle: ${e}`, {
                cause: e
            });
            throw newError;
        }
        const newMessage = `failed to wait for network idle after ${waitForNetworkIdleTimeout}ms, but the script will continue.`;
        console.warn(newMessage);
    }
    return {
        page,
        freeFn
    };
}
async function puppeteerAgentForTarget(target, preference, browser) {
    const { page, freeFn } = await launchPuppeteerPage(target, preference, browser);
    const aiActContext = resolveAiActionContext(target, preference);
    const { aiActionContext, ...preferenceToUse } = preference ?? {};
    const agent = new PuppeteerAgent(page, {
        ...preferenceToUse,
        aiActContext,
        forceSameTabNavigation: void 0 !== target.forceSameTabNavigation ? target.forceSameTabNavigation : true
    });
    freeFn.push({
        name: 'midscene_puppeteer_agent',
        fn: ()=>agent.destroy()
    });
    return {
        agent,
        freeFn
    };
}
export { defaultUA, defaultViewportHeight, defaultViewportScale, defaultViewportWidth, defaultWaitForNetworkIdleTimeout, launchPuppeteerPage, puppeteerAgentForTarget, resolveAiActionContext };

//# sourceMappingURL=agent-launcher.mjs.map