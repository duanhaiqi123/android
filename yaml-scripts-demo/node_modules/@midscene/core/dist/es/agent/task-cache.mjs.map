{"version":3,"file":"agent/task-cache.mjs","sources":["../../../src/agent/task-cache.ts"],"sourcesContent":["import assert from 'node:assert';\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { dirname, join } from 'node:path';\nimport { isDeepStrictEqual } from 'node:util';\nimport type { TUserPrompt } from '@/ai-model';\nimport type { ElementCacheFeature } from '@/types';\nimport { getMidsceneRunSubDir } from '@midscene/shared/common';\nimport {\n  MIDSCENE_CACHE_MAX_FILENAME_LENGTH,\n  globalConfigManager,\n} from '@midscene/shared/env';\nimport { getDebug } from '@midscene/shared/logger';\nimport { ifInBrowser, ifInWorker } from '@midscene/shared/utils';\nimport { generateHashId } from '@midscene/shared/utils';\nimport { replaceIllegalPathCharsAndSpace } from '@midscene/shared/utils';\nimport yaml from 'js-yaml';\nimport semver from 'semver';\nimport { getMidsceneVersion } from './utils';\n\nconst DEFAULT_CACHE_MAX_FILENAME_LENGTH = 200;\n\nexport const debug = getDebug('cache');\n\nexport interface PlanningCache {\n  type: 'plan';\n  prompt: string;\n  yamlWorkflow: string;\n}\n\nexport interface LocateCache {\n  type: 'locate';\n  prompt: TUserPrompt;\n  cache?: ElementCacheFeature;\n  /** @deprecated kept for backward compatibility */\n  xpaths?: string[];\n}\n\nexport interface MatchCacheResult<T extends PlanningCache | LocateCache> {\n  cacheContent: T;\n  updateFn: (cb: (cache: T) => void) => void;\n}\n\nexport type CacheFileContent = {\n  midsceneVersion: string;\n  cacheId: string;\n  caches: Array<PlanningCache | LocateCache>;\n};\n\nconst lowestSupportedMidsceneVersion = '0.16.10';\nexport const cacheFileExt = '.cache.yaml';\n\nexport class TaskCache {\n  cacheId: string;\n\n  cacheFilePath?: string;\n\n  cache: CacheFileContent;\n\n  isCacheResultUsed: boolean; // a flag to indicate if the cache result should be used\n  cacheOriginalLength: number;\n\n  readOnlyMode: boolean; // a flag to indicate if the cache is in read-only mode\n\n  writeOnlyMode: boolean; // a flag to indicate if the cache is in write-only mode\n\n  private matchedCacheIndices: Set<string> = new Set(); // Track matched records\n\n  constructor(\n    cacheId: string,\n    isCacheResultUsed: boolean,\n    cacheFilePath?: string,\n    options: { readOnly?: boolean; writeOnly?: boolean } = {},\n  ) {\n    assert(cacheId, 'cacheId is required');\n    let safeCacheId = replaceIllegalPathCharsAndSpace(cacheId);\n    const cacheMaxFilenameLength =\n      globalConfigManager.getEnvConfigInNumber(\n        MIDSCENE_CACHE_MAX_FILENAME_LENGTH,\n      ) || DEFAULT_CACHE_MAX_FILENAME_LENGTH;\n    if (Buffer.byteLength(safeCacheId, 'utf8') > cacheMaxFilenameLength) {\n      const prefix = safeCacheId.slice(0, 32);\n      const hash = generateHashId(undefined, safeCacheId);\n      safeCacheId = `${prefix}-${hash}`;\n    }\n    this.cacheId = safeCacheId;\n\n    this.cacheFilePath =\n      ifInBrowser || ifInWorker\n        ? undefined\n        : cacheFilePath ||\n          join(getMidsceneRunSubDir('cache'), `${this.cacheId}${cacheFileExt}`);\n    const readOnlyMode = Boolean(options?.readOnly);\n    const writeOnlyMode = Boolean(options?.writeOnly);\n\n    if (readOnlyMode && writeOnlyMode) {\n      throw new Error('TaskCache cannot be both read-only and write-only');\n    }\n\n    this.isCacheResultUsed = writeOnlyMode ? false : isCacheResultUsed;\n    this.readOnlyMode = readOnlyMode;\n    this.writeOnlyMode = writeOnlyMode;\n\n    let cacheContent;\n    if (this.cacheFilePath && !this.writeOnlyMode) {\n      cacheContent = this.loadCacheFromFile();\n    }\n    if (!cacheContent) {\n      cacheContent = {\n        midsceneVersion: getMidsceneVersion(),\n        cacheId: this.cacheId,\n        caches: [],\n      };\n    }\n    this.cache = cacheContent;\n    this.cacheOriginalLength = this.isCacheResultUsed\n      ? this.cache.caches.length\n      : 0;\n  }\n\n  matchCache(\n    prompt: TUserPrompt,\n    type: 'plan' | 'locate',\n  ): MatchCacheResult<PlanningCache | LocateCache> | undefined {\n    if (!this.isCacheResultUsed) {\n      return undefined;\n    }\n    // Find the first unused matching cache\n    const promptStr =\n      typeof prompt === 'string' ? prompt : JSON.stringify(prompt);\n    for (let i = 0; i < this.cacheOriginalLength; i++) {\n      const item = this.cache.caches[i];\n      const key = `${type}:${promptStr}:${i}`;\n      if (\n        item.type === type &&\n        isDeepStrictEqual(item.prompt, prompt) &&\n        !this.matchedCacheIndices.has(key)\n      ) {\n        if (item.type === 'locate') {\n          const locateItem = item as LocateCache;\n          if (!locateItem.cache && Array.isArray(locateItem.xpaths)) {\n            locateItem.cache = { xpaths: locateItem.xpaths };\n          }\n          if ('xpaths' in locateItem) {\n            locateItem.xpaths = undefined;\n          }\n        }\n        this.matchedCacheIndices.add(key);\n        debug(\n          'cache found and marked as used, type: %s, prompt: %s, index: %d',\n          type,\n          prompt,\n          i,\n        );\n        return {\n          cacheContent: item,\n          updateFn: (cb: (cache: PlanningCache | LocateCache) => void) => {\n            debug(\n              'will call updateFn to update cache, type: %s, prompt: %s, index: %d',\n              type,\n              prompt,\n              i,\n            );\n            cb(item);\n\n            if (this.readOnlyMode) {\n              debug(\n                'read-only mode, cache updated in memory but not flushed to file',\n              );\n              return;\n            }\n\n            debug(\n              'cache updated, will flush to file, type: %s, prompt: %s, index: %d',\n              type,\n              prompt,\n              i,\n            );\n            this.flushCacheToFile();\n          },\n        };\n      }\n    }\n    debug('no unused cache found, type: %s, prompt: %s', type, prompt);\n    return undefined;\n  }\n\n  matchPlanCache(prompt: string): MatchCacheResult<PlanningCache> | undefined {\n    return this.matchCache(prompt, 'plan') as\n      | MatchCacheResult<PlanningCache>\n      | undefined;\n  }\n\n  matchLocateCache(\n    prompt: TUserPrompt,\n  ): MatchCacheResult<LocateCache> | undefined {\n    return this.matchCache(prompt, 'locate') as\n      | MatchCacheResult<LocateCache>\n      | undefined;\n  }\n\n  appendCache(cache: PlanningCache | LocateCache) {\n    debug('will append cache', cache);\n    this.cache.caches.push(cache);\n\n    if (this.readOnlyMode) {\n      debug('read-only mode, cache appended to memory but not flushed to file');\n      return;\n    }\n\n    this.flushCacheToFile();\n  }\n\n  loadCacheFromFile() {\n    const cacheFile = this.cacheFilePath;\n    assert(cacheFile, 'cache file path is required');\n\n    if (!existsSync(cacheFile)) {\n      debug('no cache file found, path: %s', cacheFile);\n      return undefined;\n    }\n\n    // detect old cache file\n    const jsonTypeCacheFile = cacheFile.replace(cacheFileExt, '.json');\n    if (existsSync(jsonTypeCacheFile) && this.isCacheResultUsed) {\n      console.warn(\n        `An outdated cache file from an earlier version of Midscene has been detected. Since version 0.17, we have implemented an improved caching strategy. Please delete the old file located at: ${jsonTypeCacheFile}.`,\n      );\n      return undefined;\n    }\n\n    try {\n      const data = readFileSync(cacheFile, 'utf8');\n      const jsonData = yaml.load(data) as CacheFileContent;\n\n      const version = getMidsceneVersion();\n      if (!version) {\n        debug('no midscene version info, will not read cache from file');\n        return undefined;\n      }\n\n      if (\n        semver.lt(jsonData.midsceneVersion, lowestSupportedMidsceneVersion) &&\n        !jsonData.midsceneVersion.includes('beta') // for internal test\n      ) {\n        console.warn(\n          `You are using an old version of Midscene cache file, and we cannot match any info from it. Starting from Midscene v0.17, we changed our strategy to use xpath for cache info, providing better performance.\\nPlease delete the existing cache and rebuild it. Sorry for the inconvenience.\\ncache file: ${cacheFile}`,\n        );\n        return undefined;\n      }\n\n      debug(\n        'cache loaded from file, path: %s, cache version: %s, record length: %s',\n        cacheFile,\n        jsonData.midsceneVersion,\n        jsonData.caches.length,\n      );\n      jsonData.midsceneVersion = getMidsceneVersion(); // update the version\n      return jsonData;\n    } catch (err) {\n      debug(\n        'cache file exists but load failed, path: %s, error: %s',\n        cacheFile,\n        err,\n      );\n      return undefined;\n    }\n  }\n\n  flushCacheToFile(options?: { cleanUnused?: boolean }) {\n    const version = getMidsceneVersion();\n    if (!version) {\n      debug('no midscene version info, will not write cache to file');\n      return;\n    }\n\n    if (!this.cacheFilePath) {\n      debug('no cache file path, will not write cache to file');\n      return;\n    }\n\n    // Clean unused caches if requested\n    if (options?.cleanUnused) {\n      // Skip cleaning in write-only mode or when cache is not used\n      if (this.isCacheResultUsed) {\n        const originalLength = this.cache.caches.length;\n\n        // Collect indices of used caches\n        const usedIndices = new Set<number>();\n        for (const key of this.matchedCacheIndices) {\n          // key format: \"type:prompt:index\"\n          const parts = key.split(':');\n          const index = Number.parseInt(parts[parts.length - 1], 10);\n          if (!Number.isNaN(index)) {\n            usedIndices.add(index);\n          }\n        }\n\n        // Filter: keep used caches and newly added caches\n        this.cache.caches = this.cache.caches.filter((_, index) => {\n          const isUsed = usedIndices.has(index);\n          const isNew = index >= this.cacheOriginalLength;\n          return isUsed || isNew;\n        });\n\n        const removedCount = originalLength - this.cache.caches.length;\n        if (removedCount > 0) {\n          debug('cleaned %d unused cache record(s)', removedCount);\n        } else {\n          debug('no unused cache to clean');\n        }\n      } else {\n        debug('skip cleaning: cache is not used for reading');\n      }\n    }\n\n    try {\n      const dir = dirname(this.cacheFilePath);\n      if (!existsSync(dir)) {\n        mkdirSync(dir, { recursive: true });\n        debug('created cache directory: %s', dir);\n      }\n\n      // Sort caches to ensure plan entries come before locate entries for better readability\n      // Create a sorted copy for writing to disk while keeping in-memory order unchanged\n      const sortedCaches = [...this.cache.caches].sort((a, b) => {\n        if (a.type === 'plan' && b.type === 'locate') return -1;\n        if (a.type === 'locate' && b.type === 'plan') return 1;\n        return 0;\n      });\n\n      const cacheToWrite = {\n        ...this.cache,\n        caches: sortedCaches,\n      };\n\n      const yamlData = yaml.dump(cacheToWrite);\n      writeFileSync(this.cacheFilePath, yamlData);\n      debug('cache flushed to file: %s', this.cacheFilePath);\n    } catch (err) {\n      debug(\n        'write cache to file failed, path: %s, error: %s',\n        this.cacheFilePath,\n        err,\n      );\n    }\n  }\n\n  updateOrAppendCacheRecord(\n    newRecord: PlanningCache | LocateCache,\n    cachedRecord?: MatchCacheResult<PlanningCache | LocateCache>,\n  ) {\n    if (cachedRecord) {\n      // update existing record\n      if (newRecord.type === 'plan') {\n        cachedRecord.updateFn((cache) => {\n          (cache as PlanningCache).yamlWorkflow = newRecord.yamlWorkflow;\n        });\n      } else {\n        cachedRecord.updateFn((cache) => {\n          const locateCache = cache as LocateCache;\n          locateCache.cache = newRecord.cache;\n          if ('xpaths' in locateCache) {\n            locateCache.xpaths = undefined;\n          }\n        });\n      }\n    } else {\n      this.appendCache(newRecord);\n    }\n  }\n}\n"],"names":["DEFAULT_CACHE_MAX_FILENAME_LENGTH","debug","getDebug","lowestSupportedMidsceneVersion","cacheFileExt","TaskCache","prompt","type","promptStr","JSON","i","item","key","isDeepStrictEqual","locateItem","Array","undefined","cb","cache","cacheFile","assert","existsSync","jsonTypeCacheFile","console","data","readFileSync","jsonData","yaml","version","getMidsceneVersion","semver","err","options","originalLength","usedIndices","Set","parts","index","Number","_","isUsed","isNew","removedCount","dir","dirname","mkdirSync","sortedCaches","a","b","cacheToWrite","yamlData","writeFileSync","newRecord","cachedRecord","locateCache","cacheId","isCacheResultUsed","cacheFilePath","safeCacheId","replaceIllegalPathCharsAndSpace","cacheMaxFilenameLength","globalConfigManager","MIDSCENE_CACHE_MAX_FILENAME_LENGTH","Buffer","prefix","hash","generateHashId","ifInBrowser","ifInWorker","join","getMidsceneRunSubDir","readOnlyMode","Boolean","writeOnlyMode","Error","cacheContent"],"mappings":"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"}