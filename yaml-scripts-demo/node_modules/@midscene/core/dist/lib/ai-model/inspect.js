"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    AiLocateElement: ()=>AiLocateElement,
    AiJudgeOrderSensitive: ()=>AiJudgeOrderSensitive,
    AiExtractElementInfo: ()=>AiExtractElementInfo,
    AiLocateSection: ()=>AiLocateSection
});
const dom_util_namespaceObject = require("@midscene/shared/extractor/dom-util");
const img_namespaceObject = require("@midscene/shared/img");
const logger_namespaceObject = require("@midscene/shared/logger");
const utils_namespaceObject = require("@midscene/shared/utils");
const external_common_js_namespaceObject = require("../common.js");
const extraction_js_namespaceObject = require("./prompt/extraction.js");
const llm_locator_js_namespaceObject = require("./prompt/llm-locator.js");
const llm_section_locator_js_namespaceObject = require("./prompt/llm-section-locator.js");
const order_sensitive_judge_js_namespaceObject = require("./prompt/order-sensitive-judge.js");
const index_js_namespaceObject = require("./service-caller/index.js");
const debugInspect = (0, logger_namespaceObject.getDebug)('ai:inspect');
const debugSection = (0, logger_namespaceObject.getDebug)('ai:section');
const extraTextFromUserPrompt = (prompt)=>{
    if ('string' == typeof prompt) return prompt;
    return prompt.prompt;
};
const promptsToChatParam = async (multimodalPrompt)=>{
    const msgs = [];
    if (multimodalPrompt?.images?.length) {
        msgs.push({
            role: 'user',
            content: [
                {
                    type: 'text',
                    text: 'Next, I will provide all the reference images.'
                }
            ]
        });
        for (const item of multimodalPrompt.images){
            const base64 = await (0, img_namespaceObject.preProcessImageUrl)(item.url, !!multimodalPrompt.convertHttpImage2Base64);
            msgs.push({
                role: 'user',
                content: [
                    {
                        type: 'text',
                        text: `this is the reference image named '${item.name}':`
                    }
                ]
            });
            msgs.push({
                role: 'user',
                content: [
                    {
                        type: 'image_url',
                        image_url: {
                            url: base64,
                            detail: 'high'
                        }
                    }
                ]
            });
        }
    }
    return msgs;
};
async function AiLocateElement(options) {
    const { context, targetElementDescription, callAIFn, modelConfig } = options;
    const { vlMode } = modelConfig;
    const { screenshotBase64 } = context;
    (0, utils_namespaceObject.assert)(targetElementDescription, "cannot find the target element description");
    const targetElementDescriptionText = extraTextFromUserPrompt(targetElementDescription);
    const userInstructionPrompt = (0, llm_locator_js_namespaceObject.findElementPrompt)(targetElementDescriptionText);
    const systemPrompt = (0, llm_locator_js_namespaceObject.systemPromptToLocateElement)(vlMode);
    let imagePayload = screenshotBase64;
    let imageWidth = context.size.width;
    let imageHeight = context.size.height;
    let originalImageWidth = imageWidth;
    let originalImageHeight = imageHeight;
    if (options.searchConfig) {
        (0, utils_namespaceObject.assert)(options.searchConfig.rect, 'searchArea is provided but its rect cannot be found. Failed to locate element');
        (0, utils_namespaceObject.assert)(options.searchConfig.imageBase64, 'searchArea is provided but its imageBase64 cannot be found. Failed to locate element');
        imagePayload = options.searchConfig.imageBase64;
        imageWidth = options.searchConfig.rect?.width;
        imageHeight = options.searchConfig.rect?.height;
        originalImageWidth = imageWidth;
        originalImageHeight = imageHeight;
    } else if ('qwen2.5-vl' === vlMode) {
        const paddedResult = await (0, img_namespaceObject.paddingToMatchBlockByBase64)(imagePayload);
        imageWidth = paddedResult.width;
        imageHeight = paddedResult.height;
        imagePayload = paddedResult.imageBase64;
    }
    const msgs = [
        {
            role: 'system',
            content: systemPrompt
        },
        {
            role: 'user',
            content: [
                {
                    type: 'image_url',
                    image_url: {
                        url: imagePayload,
                        detail: 'high'
                    }
                },
                {
                    type: 'text',
                    text: userInstructionPrompt
                }
            ]
        }
    ];
    if ('string' != typeof targetElementDescription) {
        const addOns = await promptsToChatParam({
            images: targetElementDescription.images,
            convertHttpImage2Base64: targetElementDescription.convertHttpImage2Base64
        });
        msgs.push(...addOns);
    }
    const res = await callAIFn(msgs, external_common_js_namespaceObject.AIActionType.INSPECT_ELEMENT, modelConfig);
    const rawResponse = JSON.stringify(res.content);
    let resRect;
    let matchedElements = 'elements' in res.content ? res.content.elements : [];
    let errors = 'errors' in res.content ? res.content.errors : [];
    try {
        if ('bbox' in res.content && Array.isArray(res.content.bbox) && res.content.bbox.length >= 1) {
            resRect = (0, external_common_js_namespaceObject.adaptBboxToRect)(res.content.bbox, imageWidth, imageHeight, options.searchConfig?.rect?.left, options.searchConfig?.rect?.top, originalImageWidth, originalImageHeight, vlMode);
            debugInspect('resRect', resRect);
            const rectCenter = {
                x: resRect.left + resRect.width / 2,
                y: resRect.top + resRect.height / 2
            };
            const element = (0, dom_util_namespaceObject.generateElementByPosition)(rectCenter, targetElementDescriptionText);
            errors = [];
            if (element) matchedElements = [
                element
            ];
        }
    } catch (e) {
        const msg = e instanceof Error ? `Failed to parse bbox: ${e.message}` : 'unknown error in locate';
        if (errors && errors?.length !== 0) errors.push(`(${msg})`);
        else errors = [
            msg
        ];
    }
    return {
        rect: resRect,
        parseResult: {
            elements: matchedElements,
            errors: errors
        },
        rawResponse,
        usage: res.usage
    };
}
async function AiLocateSection(options) {
    const { context, sectionDescription, modelConfig } = options;
    const { vlMode } = modelConfig;
    const { screenshotBase64 } = context;
    const systemPrompt = (0, llm_section_locator_js_namespaceObject.systemPromptToLocateSection)(vlMode);
    const sectionLocatorInstructionText = (0, llm_section_locator_js_namespaceObject.sectionLocatorInstruction)(extraTextFromUserPrompt(sectionDescription));
    const msgs = [
        {
            role: 'system',
            content: systemPrompt
        },
        {
            role: 'user',
            content: [
                {
                    type: 'image_url',
                    image_url: {
                        url: screenshotBase64,
                        detail: 'high'
                    }
                },
                {
                    type: 'text',
                    text: sectionLocatorInstructionText
                }
            ]
        }
    ];
    if ('string' != typeof sectionDescription) {
        const addOns = await promptsToChatParam({
            images: sectionDescription.images,
            convertHttpImage2Base64: sectionDescription.convertHttpImage2Base64
        });
        msgs.push(...addOns);
    }
    const result = await (0, index_js_namespaceObject.callAIWithObjectResponse)(msgs, external_common_js_namespaceObject.AIActionType.EXTRACT_DATA, modelConfig);
    let sectionRect;
    const sectionBbox = result.content.bbox;
    if (sectionBbox) {
        const targetRect = (0, external_common_js_namespaceObject.adaptBboxToRect)(sectionBbox, context.size.width, context.size.height, 0, 0, context.size.width, context.size.height, vlMode);
        debugSection('original targetRect %j', targetRect);
        const referenceBboxList = result.content.references_bbox || [];
        debugSection('referenceBboxList %j', referenceBboxList);
        const referenceRects = referenceBboxList.filter((bbox)=>Array.isArray(bbox)).map((bbox)=>(0, external_common_js_namespaceObject.adaptBboxToRect)(bbox, context.size.width, context.size.height, 0, 0, context.size.width, context.size.height, vlMode));
        debugSection('referenceRects %j', referenceRects);
        const mergedRect = (0, external_common_js_namespaceObject.mergeRects)([
            targetRect,
            ...referenceRects
        ]);
        debugSection('mergedRect %j', mergedRect);
        sectionRect = (0, external_common_js_namespaceObject.expandSearchArea)(mergedRect, context.size, vlMode);
        debugSection('expanded sectionRect %j', sectionRect);
    }
    let imageBase64 = screenshotBase64;
    if (sectionRect) {
        const croppedResult = await (0, img_namespaceObject.cropByRect)(screenshotBase64, sectionRect, 'qwen2.5-vl' === vlMode);
        imageBase64 = croppedResult.imageBase64;
        sectionRect.width = croppedResult.width;
        sectionRect.height = croppedResult.height;
    }
    return {
        rect: sectionRect,
        imageBase64,
        error: result.content.error,
        rawResponse: JSON.stringify(result.content),
        usage: result.usage
    };
}
async function AiExtractElementInfo(options) {
    const { dataQuery, context, extractOption, multimodalPrompt, modelConfig } = options;
    const systemPrompt = (0, extraction_js_namespaceObject.systemPromptToExtract)();
    const { screenshotBase64 } = context;
    const extractDataPromptText = (0, extraction_js_namespaceObject.extractDataQueryPrompt)(options.pageDescription || '', dataQuery);
    const userContent = [];
    if (extractOption?.screenshotIncluded !== false) userContent.push({
        type: 'image_url',
        image_url: {
            url: screenshotBase64,
            detail: 'high'
        }
    });
    userContent.push({
        type: 'text',
        text: extractDataPromptText
    });
    const msgs = [
        {
            role: 'system',
            content: systemPrompt
        },
        {
            role: 'user',
            content: userContent
        }
    ];
    if (multimodalPrompt) {
        const addOns = await promptsToChatParam({
            images: multimodalPrompt.images,
            convertHttpImage2Base64: multimodalPrompt.convertHttpImage2Base64
        });
        msgs.push(...addOns);
    }
    const result = await (0, index_js_namespaceObject.callAIWithObjectResponse)(msgs, external_common_js_namespaceObject.AIActionType.EXTRACT_DATA, modelConfig);
    return {
        parseResult: result.content,
        usage: result.usage
    };
}
async function AiJudgeOrderSensitive(description, callAIFn, modelConfig) {
    const systemPrompt = (0, order_sensitive_judge_js_namespaceObject.systemPromptToJudgeOrderSensitive)();
    const userPrompt = (0, order_sensitive_judge_js_namespaceObject.orderSensitiveJudgePrompt)(description);
    const msgs = [
        {
            role: 'system',
            content: systemPrompt
        },
        {
            role: 'user',
            content: userPrompt
        }
    ];
    const result = await callAIFn(msgs, external_common_js_namespaceObject.AIActionType.INSPECT_ELEMENT, modelConfig);
    return {
        isOrderSensitive: result.content.isOrderSensitive ?? false,
        usage: result.usage
    };
}
exports.AiExtractElementInfo = __webpack_exports__.AiExtractElementInfo;
exports.AiJudgeOrderSensitive = __webpack_exports__.AiJudgeOrderSensitive;
exports.AiLocateElement = __webpack_exports__.AiLocateElement;
exports.AiLocateSection = __webpack_exports__.AiLocateSection;
for(var __rspack_i in __webpack_exports__)if (-1 === [
    "AiExtractElementInfo",
    "AiJudgeOrderSensitive",
    "AiLocateElement",
    "AiLocateSection"
].indexOf(__rspack_i)) exports[__rspack_i] = __webpack_exports__[__rspack_i];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=inspect.js.map