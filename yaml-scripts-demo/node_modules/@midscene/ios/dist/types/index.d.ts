import { AbstractInterface } from '@midscene/core/device';
import type { ActionParam } from '@midscene/core';
import type { ActionReturn } from '@midscene/core';
import { Agent } from '@midscene/core/agent';
import { AgentOpt } from '@midscene/core/agent';
import { DeviceAction } from '@midscene/core';
import type { ElementInfo } from '@midscene/shared/extractor';
import { InterfaceType } from '@midscene/core';
import { IOSDeviceInputOpt } from '@midscene/core/device';
import { IOSDeviceOpt } from '@midscene/core/device';
import { overrideAIConfig } from '@midscene/shared/env';
import { Point } from '@midscene/core';
import { Size } from '@midscene/core';
import { WebDriverClient } from '@midscene/webdriver';
import { z } from '@midscene/core';

declare type ActionArgs<T extends DeviceAction> = [ActionParam<T>] extends [undefined] ? [] : [ActionParam<T>];

export declare function agentFromWebDriverAgent(opts?: IOSAgentOpt & IOSDeviceOpt): Promise<IOSAgent>;

export declare function checkIOSEnvironment(): Promise<{
    available: boolean;
    error?: string;
}>;

declare type DeviceActionIOSAppSwitcher = DeviceAction<undefined, void>;

declare type DeviceActionIOSHomeButton = DeviceAction<undefined, void>;

declare type DeviceActionLaunch = DeviceAction<LaunchParam, void>;

declare type DeviceActionRunWdaRequest = DeviceAction<RunWdaRequestParam, RunWdaRequestReturn>;

export declare class IOSAgent extends Agent<IOSDevice> {
    /**
     * Launch an iOS app or URL
     * Type-safe wrapper around the Launch action from actionSpace
     */
    launch: WrappedAction<DeviceActionLaunch>;
    /**
     * Execute WebDriverAgent API request directly
     * Type-safe wrapper around the RunWdaRequest action from actionSpace
     */
    runWdaRequest: WrappedAction<DeviceActionRunWdaRequest>;
    /**
     * Trigger the system home operation on iOS devices
     */
    home: WrappedAction<DeviceActionIOSHomeButton>;
    /**
     * Trigger the system app switcher operation on iOS devices
     */
    appSwitcher: WrappedAction<DeviceActionIOSAppSwitcher>;
    constructor(device: IOSDevice, opts?: IOSAgentOpt);
    private createActionWrapper;
}

export declare type IOSAgentOpt = AgentOpt;

export declare class IOSDevice implements AbstractInterface {
    private deviceId;
    private devicePixelRatio;
    private devicePixelRatioInitialized;
    private destroyed;
    private description;
    private customActions?;
    private wdaBackend;
    private wdaManager;
    interfaceType: InterfaceType;
    uri: string | undefined;
    options?: IOSDeviceOpt;
    actionSpace(): DeviceAction<any>[];
    constructor(options?: IOSDeviceOpt);
    describe(): string;
    getConnectedDeviceInfo(): Promise<{
        udid: string;
        name: string;
        model: string;
    } | null>;
    connect(): Promise<void>;
    launch(uri: string): Promise<IOSDevice>;
    getElementsInfo(): Promise<ElementInfo[]>;
    getElementsNodeTree(): Promise<any>;
    private initializeDevicePixelRatio;
    getScreenSize(): Promise<{
        width: number;
        height: number;
        scale: number;
    }>;
    size(): Promise<Size>;
    screenshotBase64(): Promise<string>;
    clearInput(element: ElementInfo): Promise<void>;
    url(): Promise<string>;
    tap(x: number, y: number): Promise<void>;
    mouseClick(x: number, y: number): Promise<void>;
    doubleTap(x: number, y: number): Promise<void>;
    tripleTap(x: number, y: number): Promise<void>;
    longPress(x: number, y: number, duration?: number): Promise<void>;
    swipe(fromX: number, fromY: number, toX: number, toY: number, duration?: number): Promise<void>;
    typeText(text: string, options?: IOSDeviceInputOpt): Promise<void>;
    pressKey(key: string): Promise<void>;
    scrollUp(distance?: number, startPoint?: Point): Promise<void>;
    scrollDown(distance?: number, startPoint?: Point): Promise<void>;
    scrollLeft(distance?: number, startPoint?: Point): Promise<void>;
    scrollRight(distance?: number, startPoint?: Point): Promise<void>;
    scrollUntilTop(startPoint?: Point): Promise<void>;
    scrollUntilBottom(startPoint?: Point): Promise<void>;
    private compareScreenshots;
    private scrollUntilBoundary;
    scrollUntilLeft(startPoint?: Point): Promise<void>;
    scrollUntilRight(startPoint?: Point): Promise<void>;
    home(): Promise<void>;
    appSwitcher(): Promise<void>;
    hideKeyboard(keyNames?: string[]): Promise<boolean>;
    /**
     * Open a URL using WebDriverAgent
     * @param url The URL to open (supports http://, https://, and custom schemes)
     * @param options Configuration options for URL opening
     */
    openUrl(url: string, options?: {
        useSafariAsBackup?: boolean;
        waitTime?: number;
    }): Promise<void>;
    /**
     * Open a URL via Safari (backup method for real devices)
     * @param url The URL to open
     */
    openUrlViaSafari(url: string): Promise<void>;
    /**
     * Execute a WebDriverAgent API request directly
     * This is the iOS equivalent of Android's runAdbShell
     * @param method HTTP method (GET, POST, DELETE, PUT)
     * @param endpoint WebDriver API endpoint
     * @param data Optional request body data
     * @returns Response from the WebDriver API
     */
    runWdaRequest<TResult = any>(method: WDAHttpMethod, endpoint: string, data?: any): Promise<TResult>;
    destroy(): Promise<void>;
}

export declare class IOSWebDriverClient extends WebDriverClient {
    launchApp(bundleId: string): Promise<void>;
    activateApp(bundleId: string): Promise<void>;
    terminateApp(bundleId: string): Promise<void>;
    openUrl(url: string): Promise<void>;
    pressHomeButton(): Promise<void>;
    appSwitcher(): Promise<void>;
    pressKey(key: string): Promise<void>;
    /**
     * Get the currently focused element's WebDriver ID
     * @returns WebDriver element ID or null if no element is focused
     */
    getActiveElement(): Promise<string | null>;
    /**
     * Clear an element using WebDriver's clear endpoint
     * @param elementId WebDriver element ID
     */
    clearElement(elementId: string): Promise<void>;
    /**
     * Clear the currently focused input field using WebDriver Clear API
     * @returns true if successful, false otherwise
     */
    clearActiveElement(): Promise<boolean>;
    private normalizeKeyName;
    dismissKeyboard(keyNames?: string[]): Promise<boolean>;
    typeText(text: string): Promise<void>;
    tap(x: number, y: number): Promise<void>;
    swipe(fromX: number, fromY: number, toX: number, toY: number, duration?: number): Promise<void>;
    longPress(x: number, y: number, duration?: number): Promise<void>;
    doubleTap(x: number, y: number): Promise<void>;
    tripleTap(x: number, y: number): Promise<void>;
    getScreenScale(): Promise<number | null>;
    createSession(capabilities?: any): Promise<any>;
    private setupIOSSession;
    /**
     * Execute a WebDriverAgent API request directly
     * This is the iOS equivalent of Android's runAdbShell
     * @param method HTTP method (GET, POST, DELETE, etc.)
     * @param endpoint WebDriver API endpoint
     * @param data Optional request body data
     * @returns Response from the WebDriver API
     */
    executeRequest<TResult = any>(method: string, endpoint: string, data?: any): Promise<TResult>;
}

declare type LaunchParam = z.infer<typeof launchParamSchema>;

declare const launchParamSchema: z.ZodString;

export { overrideAIConfig }

declare type RunWdaRequestParam = z.infer<typeof runWdaRequestParamSchema>;

declare const runWdaRequestParamSchema: z.ZodObject<{
    method: z.ZodEnum<["GET", "POST", "DELETE", "PUT"]>;
    endpoint: z.ZodString;
    data: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
}, "strip", z.ZodTypeAny, {
    method: "POST" | "GET" | "DELETE" | "PUT";
    endpoint: string;
    data?: z.objectOutputType<{}, z.ZodTypeAny, "passthrough"> | undefined;
}, {
    method: "POST" | "GET" | "DELETE" | "PUT";
    endpoint: string;
    data?: z.objectInputType<{}, z.ZodTypeAny, "passthrough"> | undefined;
}>;

declare type RunWdaRequestReturn = Awaited<ReturnType<IOSDevice['runWdaRequest']>>;

/**
 * HTTP methods supported by WebDriverAgent API
 */
declare const WDA_HTTP_METHODS: readonly ["GET", "POST", "DELETE", "PUT"];

declare type WDAHttpMethod = (typeof WDA_HTTP_METHODS)[number];

/**
 * Helper type to convert DeviceAction to wrapped method signature
 */
declare type WrappedAction<T extends DeviceAction> = (...args: ActionArgs<T>) => Promise<ActionReturn<T>>;

export { }
