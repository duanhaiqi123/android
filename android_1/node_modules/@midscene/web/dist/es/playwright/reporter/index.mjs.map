{"version":3,"file":"playwright/reporter/index.mjs","sources":["../../../../src/playwright/reporter/index.ts"],"sourcesContent":["import { readFileSync, rmSync } from 'node:fs';\nimport type { ReportDumpWithAttributes } from '@midscene/core';\nimport { getReportFileName, printReportMsg } from '@midscene/core/agent';\nimport { writeDumpReport } from '@midscene/core/utils';\nimport { replaceIllegalPathCharsAndSpace } from '@midscene/shared/utils';\nimport type {\n  FullConfig,\n  Reporter,\n  Suite,\n  TestCase,\n  TestResult,\n} from '@playwright/test/reporter';\n\ninterface MidsceneReporterOptions {\n  type?: 'merged' | 'separate';\n}\n\nclass MidsceneReporter implements Reporter {\n  private mergedFilename?: string;\n  private testTitleToFilename = new Map<string, string>();\n  mode?: 'merged' | 'separate';\n\n  // Track all temp files created during this test run for cleanup\n  private tempFiles = new Set<string>();\n\n  constructor(options: MidsceneReporterOptions = {}) {\n    // Set mode from constructor options (official Playwright way)\n    this.mode = MidsceneReporter.getMode(options.type ?? 'merged');\n  }\n\n  private static getMode(reporterType: string): 'merged' | 'separate' {\n    if (!reporterType) {\n      return 'merged';\n    }\n    if (reporterType !== 'merged' && reporterType !== 'separate') {\n      throw new Error(\n        `Unknown reporter type in playwright config: ${reporterType}, only support 'merged' or 'separate'`,\n      );\n    }\n    return reporterType;\n  }\n\n  private getSeparatedFilename(testTitle: string): string {\n    if (!this.testTitleToFilename.has(testTitle)) {\n      const baseTag = `playwright-${replaceIllegalPathCharsAndSpace(testTitle)}`;\n      const generatedFilename = getReportFileName(baseTag);\n      this.testTitleToFilename.set(testTitle, generatedFilename);\n    }\n    return this.testTitleToFilename.get(testTitle)!;\n  }\n\n  private getReportFilename(testTitle?: string): string {\n    if (this.mode === 'merged') {\n      if (!this.mergedFilename) {\n        this.mergedFilename = getReportFileName('playwright-merged');\n      }\n      return this.mergedFilename;\n    } else if (this.mode === 'separate') {\n      if (!testTitle) throw new Error('testTitle is required in separate mode');\n      return this.getSeparatedFilename(testTitle);\n    }\n    throw new Error(`Unknown mode: ${this.mode}`);\n  }\n\n  private updateReport(testData: ReportDumpWithAttributes) {\n    if (!testData || !this.mode) return;\n    const fileName = this.getReportFilename(\n      testData.attributes?.playwright_test_title,\n    );\n    const reportPath = writeDumpReport(\n      fileName,\n      testData,\n      this.mode === 'merged',\n    );\n    reportPath && printReportMsg(reportPath);\n  }\n\n  async onBegin(config: FullConfig, suite: Suite) {}\n\n  onTestBegin(_test: TestCase, _result: TestResult) {\n    // logger(`Starting test ${test.title}`);\n  }\n\n  onTestEnd(test: TestCase, result: TestResult) {\n    const dumpAnnotation = test.annotations.find((annotation) => {\n      return annotation.type === 'MIDSCENE_DUMP_ANNOTATION';\n    });\n    if (!dumpAnnotation?.description) return;\n\n    const tempFilePath = dumpAnnotation.description;\n\n    // Track this temp file for potential cleanup in onEnd\n    this.tempFiles.add(tempFilePath);\n\n    let dumpString: string | undefined;\n\n    try {\n      dumpString = readFileSync(tempFilePath, 'utf-8');\n    } catch (error) {\n      console.error(\n        `Failed to read Midscene dump file: ${tempFilePath}`,\n        error,\n      );\n      // Don't return here - we still need to clean up the temp file\n    }\n\n    // Only update report if we successfully read the dump\n    if (dumpString) {\n      const retry = result.retry ? `(retry #${result.retry})` : '';\n      const testId = `${test.id}${retry}`;\n      const testData: ReportDumpWithAttributes = {\n        dumpString,\n        attributes: {\n          playwright_test_id: testId,\n          playwright_test_title: `${test.title}${retry}`,\n          playwright_test_status: result.status,\n          playwright_test_duration: result.duration,\n        },\n      };\n\n      this.updateReport(testData);\n    }\n\n    // Always try to clean up temp file\n    try {\n      rmSync(tempFilePath, { force: true });\n      // If successfully deleted, remove from tracking\n      this.tempFiles.delete(tempFilePath);\n    } catch (error) {\n      console.warn(\n        `Failed to delete Midscene temp file: ${tempFilePath}`,\n        error,\n      );\n      // Keep in tempFiles for cleanup in onEnd\n    }\n  }\n\n  onEnd() {\n    // Clean up any remaining temp files that weren't deleted in onTestEnd\n    if (this.tempFiles.size > 0) {\n      console.log(\n        `Midscene: Cleaning up ${this.tempFiles.size} remaining temp file(s)...`,\n      );\n\n      for (const filePath of this.tempFiles) {\n        try {\n          rmSync(filePath, { force: true });\n        } catch (error) {\n          // Silently ignore - file may have been deleted already\n        }\n      }\n\n      this.tempFiles.clear();\n    }\n  }\n}\n\nexport default MidsceneReporter;\n"],"names":["MidsceneReporter","reporterType","Error","testTitle","baseTag","replaceIllegalPathCharsAndSpace","generatedFilename","getReportFileName","testData","fileName","reportPath","writeDumpReport","printReportMsg","config","suite","_test","_result","test","result","dumpAnnotation","annotation","tempFilePath","dumpString","readFileSync","error","console","retry","testId","rmSync","filePath","options","Map","Set"],"mappings":"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"}