import { overrideAIConfig } from "@midscene/shared/env";
import { uuid } from "@midscene/shared/utils";
import { executeAction, parseStructuredParams } from "../common.mjs";
import { BasePlaygroundAdapter } from "./base.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class LocalExecutionAdapter extends BasePlaygroundAdapter {
    get id() {
        return this._id;
    }
    onDumpUpdate(callback) {
        this.dumpUpdateCallback = void 0;
        this.dumpUpdateCallback = callback;
    }
    setProgressCallback(callback) {
        this.progressCallback = void 0;
        this.progressCallback = callback;
    }
    async parseStructuredParams(action, params, options) {
        return await parseStructuredParams(action, params, options);
    }
    formatErrorMessage(error) {
        const errorMessage = error?.message || '';
        if (errorMessage.includes('of different extension')) return 'Conflicting extension detected. Please disable the suspicious plugins and refresh the page. Guide: https://midscenejs.com/quick-experience.html#faq';
        return this.formatBasicErrorMessage(error);
    }
    async getActionSpace(context) {
        if (this.agent?.getActionSpace) return await this.agent.getActionSpace();
        if (this.agent && 'interface' in this.agent && 'object' == typeof this.agent.interface) {
            const page = this.agent.interface;
            if (page?.actionSpace) return page.actionSpace();
        }
        if (context && 'object' == typeof context && 'actionSpace' in context) {
            const contextPage = context;
            return contextPage.actionSpace();
        }
        return [];
    }
    async checkStatus() {
        return true;
    }
    async overrideConfig(aiConfig) {
        overrideAIConfig(aiConfig);
    }
    async detachDebuggerSafely() {
        try {
            const page = this.agent?.interface;
            await page?.detachDebugger?.();
        } catch (error) {
            console.warn('Failed to detach debugger:', error);
        }
    }
    async executeAction(actionType, value, options) {
        const actionSpace = await this.getActionSpace();
        let removeListener;
        try {
            this.agent.resetDump?.();
        } catch (error) {
            console.warn('Failed to reset dump before execution:', error);
        }
        if (options.requestId && this.agent) {
            this.currentRequestId = options.requestId;
            removeListener = this.agent.addDumpUpdateListener((dump, executionDump)=>{
                if (this.currentRequestId !== options.requestId) return;
                if (this.dumpUpdateCallback) this.dumpUpdateCallback(dump, executionDump);
            });
        }
        try {
            let result = null;
            let executionError = null;
            try {
                result = await executeAction(this.agent, actionType, actionSpace, value, options);
            } catch (error) {
                executionError = error;
            }
            const response = {
                result,
                dump: null,
                reportHTML: null,
                error: executionError ? executionError instanceof Error ? executionError.message : String(executionError) : null
            };
            try {
                if (this.agent.dumpDataString) {
                    const dumpString = this.agent.dumpDataString();
                    if (dumpString) {
                        const groupedDump = JSON.parse(dumpString);
                        response.dump = groupedDump.executions?.[0] || null;
                    }
                }
                if (this.agent.reportHTMLString) response.reportHTML = this.agent.reportHTMLString() || null;
                if (this.agent.writeOutActionDumps) this.agent.writeOutActionDumps();
            } catch (error) {
                console.error('Failed to get dump/reportHTML from agent:', error);
            }
            return response;
        } finally{
            if (removeListener) removeListener();
        }
    }
    async cancelTask(_requestId) {
        if (!this.agent) return {
            error: 'No active agent found for this requestId'
        };
        try {
            await this.agent.destroy?.();
            return {
                success: true
            };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            console.error(`Failed to cancel agent: ${errorMessage}`);
            return {
                error: `Failed to cancel: ${errorMessage}`
            };
        }
    }
    async getCurrentExecutionData() {
        const response = {
            dump: null,
            reportHTML: null
        };
        try {
            if (this.agent.dumpDataString) {
                const dumpString = this.agent.dumpDataString();
                if (dumpString) {
                    const groupedDump = JSON.parse(dumpString);
                    response.dump = groupedDump.executions?.[0] || null;
                }
            }
            if (this.agent.reportHTMLString) response.reportHTML = this.agent.reportHTMLString() || null;
        } catch (error) {
            console.error('Failed to get current execution data:', error);
        }
        return response;
    }
    async getInterfaceInfo() {
        if (!this.agent?.interface) return null;
        try {
            const type = this.agent.interface.interfaceType || 'Unknown';
            const description = this.agent.interface.describe?.() || void 0;
            return {
                type,
                description
            };
        } catch (error) {
            console.error('Failed to get interface info:', error);
            return null;
        }
    }
    constructor(agent){
        super(), _define_property(this, "agent", void 0), _define_property(this, "dumpUpdateCallback", void 0), _define_property(this, "progressCallback", void 0), _define_property(this, "_id", void 0), _define_property(this, "currentRequestId", void 0);
        this.agent = agent;
        this._id = uuid();
    }
}
export { LocalExecutionAdapter };

//# sourceMappingURL=local-execution.mjs.map