{"version":3,"file":"agent/agent.js","sources":["webpack/runtime/compat_get_default_export","webpack/runtime/define_property_getters","webpack/runtime/has_own_property","webpack/runtime/make_namespace_object","../../../src/agent/agent.ts"],"sourcesContent":["// getDefaultExport function for compatibility with non-ESM modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};\n","__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {\n  type ActionParam,\n  type ActionReturn,\n  type AgentAssertOpt,\n  type AgentDescribeElementAtPointResult,\n  type AgentOpt,\n  type AgentWaitForOpt,\n  type CacheConfig,\n  type DeviceAction,\n  type ExecutionDump,\n  type ExecutionRecorderItem,\n  type ExecutionTask,\n  type ExecutionTaskLog,\n  type ExecutionTaskPlanning,\n  type GroupedActionDump,\n  type LocateOption,\n  type LocateResultElement,\n  type LocateValidatorResult,\n  type LocatorValidatorOption,\n  type MidsceneYamlScript,\n  type OnTaskStartTip,\n  type PlanningAction,\n  type Rect,\n  type ScrollParam,\n  Service,\n  type ServiceAction,\n  type ServiceExtractOption,\n  type ServiceExtractParam,\n  type TUserPrompt,\n  type UIContext,\n} from '../index';\nexport type TestStatus =\n  | 'passed'\n  | 'failed'\n  | 'timedOut'\n  | 'skipped'\n  | 'interrupted';\nimport yaml from 'js-yaml';\n\nimport {\n  getVersion,\n  groupedActionDumpFileExt,\n  processCacheConfig,\n  reportHTMLContent,\n  stringifyDumpData,\n  writeLogFile,\n} from '@/utils';\nimport {\n  ScriptPlayer,\n  buildDetailedLocateParam,\n  parseYamlScript,\n} from '../yaml/index';\n\nimport type { AbstractInterface } from '@/device';\nimport type { TaskRunner } from '@/task-runner';\nimport {\n  type IModelConfig,\n  MIDSCENE_REPLANNING_CYCLE_LIMIT,\n  ModelConfigManager,\n  globalConfigManager,\n  globalModelConfigManager,\n} from '@midscene/shared/env';\nimport { imageInfoOfBase64, resizeImgBase64 } from '@midscene/shared/img';\nimport { getDebug } from '@midscene/shared/logger';\nimport { assert } from '@midscene/shared/utils';\nimport { defineActionAssert } from '../device';\n// import type { AndroidDeviceInputOpt } from '../device';\nimport { TaskCache } from './task-cache';\nimport { TaskExecutionError, TaskExecutor, locatePlanForLocate } from './tasks';\nimport { locateParamStr, paramStr, taskTitleStr, typeStr } from './ui-utils';\nimport {\n  commonContextParser,\n  getReportFileName,\n  parsePrompt,\n  printReportMsg,\n} from './utils';\n\nconst debug = getDebug('agent');\n\nconst distanceOfTwoPoints = (p1: [number, number], p2: [number, number]) => {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n  return Math.round(Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2));\n};\n\nconst includedInRect = (point: [number, number], rect: Rect) => {\n  const [x, y] = point;\n  const { left, top, width, height } = rect;\n  return x >= left && x <= left + width && y >= top && y <= top + height;\n};\n\nconst defaultServiceExtractOption: ServiceExtractOption = {\n  domIncluded: false,\n  screenshotIncluded: true,\n};\n\ntype CacheStrategy = NonNullable<CacheConfig['strategy']>;\n\nconst CACHE_STRATEGIES: readonly CacheStrategy[] = [\n  'read-only',\n  'read-write',\n  'write-only',\n];\n\nconst isValidCacheStrategy = (strategy: string): strategy is CacheStrategy =>\n  CACHE_STRATEGIES.some((value) => value === strategy);\n\nconst CACHE_STRATEGY_VALUES = CACHE_STRATEGIES.map(\n  (value) => `\"${value}\"`,\n).join(', ');\n\nconst legacyScrollTypeMap = {\n  once: 'singleAction',\n  untilBottom: 'scrollToBottom',\n  untilTop: 'scrollToTop',\n  untilRight: 'scrollToRight',\n  untilLeft: 'scrollToLeft',\n} as const;\n\ntype LegacyScrollType = keyof typeof legacyScrollTypeMap;\n\nconst normalizeScrollType = (\n  scrollType: ScrollParam['scrollType'] | LegacyScrollType | undefined,\n): ScrollParam['scrollType'] | undefined => {\n  if (!scrollType) {\n    return scrollType;\n  }\n\n  if (scrollType in legacyScrollTypeMap) {\n    return legacyScrollTypeMap[scrollType as LegacyScrollType];\n  }\n\n  return scrollType as ScrollParam['scrollType'];\n};\n\nconst defaultReplanningCycleLimit = 20;\nconst defaultVlmUiTarsReplanningCycleLimit = 40;\n\nexport type AiActOptions = {\n  cacheable?: boolean;\n};\n\nexport class Agent<\n  InterfaceType extends AbstractInterface = AbstractInterface,\n> {\n  interface: InterfaceType;\n\n  service: Service;\n\n  dump: GroupedActionDump;\n\n  reportFile?: string | null;\n\n  reportFileName?: string;\n\n  taskExecutor: TaskExecutor;\n\n  opts: AgentOpt;\n\n  /**\n   * If true, the agent will not perform any actions\n   */\n  dryMode = false;\n\n  onTaskStartTip?: OnTaskStartTip;\n\n  taskCache?: TaskCache;\n\n  private dumpUpdateListeners: Array<\n    (dump: string, executionDump?: ExecutionDump) => void\n  > = [];\n\n  get onDumpUpdate():\n    | ((dump: string, executionDump?: ExecutionDump) => void)\n    | undefined {\n    return this.dumpUpdateListeners[0];\n  }\n\n  set onDumpUpdate(callback:\n    | ((dump: string, executionDump?: ExecutionDump) => void)\n    | undefined) {\n    // Clear existing listeners\n    this.dumpUpdateListeners = [];\n    // Add callback to array if provided\n    if (callback) {\n      this.dumpUpdateListeners.push(callback);\n    }\n  }\n\n  destroyed = false;\n\n  modelConfigManager: ModelConfigManager;\n\n  /**\n   * Frozen page context for consistent AI operations\n   */\n  private frozenUIContext?: UIContext;\n\n  private get aiActContext(): string | undefined {\n    return this.opts.aiActContext ?? this.opts.aiActionContext;\n  }\n\n  /**\n   * Flag to track if VL model warning has been shown\n   */\n  private hasWarnedNonVLModel = false;\n\n  /**\n   * Screenshot scale factor derived from actual screenshot dimensions\n   */\n  private screenshotScale?: number;\n\n  /**\n   * Internal promise to deduplicate screenshot scale computation\n   */\n  private screenshotScalePromise?: Promise<number>;\n\n  private executionDumpIndexByRunner = new WeakMap<TaskRunner, number>();\n\n  // @deprecated use .interface instead\n  get page() {\n    return this.interface;\n  }\n\n  /**\n   * Ensures VL model warning is shown once when needed\n   */\n  private ensureVLModelWarning() {\n    if (\n      !this.hasWarnedNonVLModel &&\n      this.interface.interfaceType !== 'puppeteer' &&\n      this.interface.interfaceType !== 'playwright' &&\n      this.interface.interfaceType !== 'static' &&\n      this.interface.interfaceType !== 'chrome-extension-proxy' &&\n      this.interface.interfaceType !== 'page-over-chrome-extension-bridge'\n    ) {\n      this.modelConfigManager.throwErrorIfNonVLModel();\n      this.hasWarnedNonVLModel = true;\n    }\n  }\n\n  /**\n   * Lazily compute the ratio between the physical screenshot width and the logical page width\n   */\n  private async getScreenshotScale(context: UIContext): Promise<number> {\n    if (this.screenshotScale !== undefined) {\n      return this.screenshotScale;\n    }\n\n    if (!this.screenshotScalePromise) {\n      this.screenshotScalePromise = (async () => {\n        const pageWidth = context.size?.width;\n        assert(\n          pageWidth && pageWidth > 0,\n          `Invalid page width when computing screenshot scale: ${pageWidth}`,\n        );\n\n        debug('will get image info of base64');\n        const { width: screenshotWidth } = await imageInfoOfBase64(\n          context.screenshotBase64,\n        );\n        debug('image info of base64 done');\n\n        assert(\n          Number.isFinite(screenshotWidth) && screenshotWidth > 0,\n          `Invalid screenshot width when computing screenshot scale: ${screenshotWidth}`,\n        );\n\n        const computedScale = screenshotWidth / pageWidth;\n        assert(\n          Number.isFinite(computedScale) && computedScale > 0,\n          `Invalid computed screenshot scale: ${computedScale}`,\n        );\n\n        debug(\n          `Computed screenshot scale ${computedScale} from screenshot width ${screenshotWidth} and page width ${pageWidth}`,\n        );\n        return computedScale;\n      })();\n    }\n\n    try {\n      this.screenshotScale = await this.screenshotScalePromise;\n      return this.screenshotScale;\n    } finally {\n      this.screenshotScalePromise = undefined;\n    }\n  }\n\n  private resolveReplanningCycleLimit(\n    modelConfigForPlanning: IModelConfig,\n  ): number {\n    if (this.opts.replanningCycleLimit !== undefined) {\n      return this.opts.replanningCycleLimit;\n    }\n\n    return modelConfigForPlanning.vlMode === 'vlm-ui-tars'\n      ? defaultVlmUiTarsReplanningCycleLimit\n      : defaultReplanningCycleLimit;\n  }\n\n  constructor(interfaceInstance: InterfaceType, opts?: AgentOpt) {\n    this.interface = interfaceInstance;\n\n    const envConfig = globalConfigManager.getAllEnvConfig();\n    const envReplanningCycleLimitRaw =\n      envConfig[MIDSCENE_REPLANNING_CYCLE_LIMIT];\n    const envReplanningCycleLimit =\n      envReplanningCycleLimitRaw !== undefined\n        ? Number(envReplanningCycleLimitRaw)\n        : undefined;\n\n    this.opts = Object.assign(\n      {\n        generateReport: true,\n        autoPrintReportMsg: true,\n        groupName: 'Midscene Report',\n        groupDescription: '',\n      },\n      opts || {},\n      opts?.replanningCycleLimit === undefined &&\n        envReplanningCycleLimit !== undefined &&\n        !Number.isNaN(envReplanningCycleLimit)\n        ? { replanningCycleLimit: envReplanningCycleLimit }\n        : {},\n    );\n\n    const resolvedAiActContext =\n      this.opts.aiActContext ?? this.opts.aiActionContext;\n    if (resolvedAiActContext !== undefined) {\n      this.opts.aiActContext = resolvedAiActContext;\n      this.opts.aiActionContext ??= resolvedAiActContext;\n    }\n\n    if (\n      opts?.modelConfig &&\n      (typeof opts?.modelConfig !== 'object' || Array.isArray(opts.modelConfig))\n    ) {\n      throw new Error(\n        `opts.modelConfig must be a plain object map of env keys to values, but got ${typeof opts?.modelConfig}`,\n      );\n    }\n    // Create ModelConfigManager if modelConfig or createOpenAIClient is provided\n    // Otherwise, use the global config manager\n    const hasCustomConfig = opts?.modelConfig || opts?.createOpenAIClient;\n    this.modelConfigManager = hasCustomConfig\n      ? new ModelConfigManager(opts?.modelConfig, opts?.createOpenAIClient)\n      : globalModelConfigManager;\n\n    this.onTaskStartTip = this.opts.onTaskStartTip;\n\n    this.service = new Service(async () => {\n      return this.getUIContext();\n    });\n\n    // Process cache configuration\n    const cacheConfigObj = this.processCacheConfig(opts || {});\n    if (cacheConfigObj) {\n      this.taskCache = new TaskCache(\n        cacheConfigObj.id,\n        cacheConfigObj.enabled,\n        undefined, // cacheFilePath\n        {\n          readOnly: cacheConfigObj.readOnly,\n          writeOnly: cacheConfigObj.writeOnly,\n        },\n      );\n    }\n\n    const baseActionSpace = this.interface.actionSpace();\n    const fullActionSpace = [...baseActionSpace, defineActionAssert()];\n\n    this.taskExecutor = new TaskExecutor(this.interface, this.service, {\n      taskCache: this.taskCache,\n      onTaskStart: this.callbackOnTaskStartTip.bind(this),\n      replanningCycleLimit: this.opts.replanningCycleLimit,\n      actionSpace: fullActionSpace,\n      hooks: {\n        onTaskUpdate: (runner) => {\n          const executionDump = runner.dump();\n          this.appendExecutionDump(executionDump, runner);\n\n          // Call all registered dump update listeners\n          const dumpString = this.dumpDataString();\n          for (const listener of this.dumpUpdateListeners) {\n            try {\n              listener(dumpString, executionDump);\n            } catch (error) {\n              console.error('Error in onDumpUpdate listener', error);\n            }\n          }\n\n          this.writeOutActionDumps();\n        },\n      },\n    });\n    this.dump = this.resetDump();\n    this.reportFileName =\n      opts?.reportFileName ||\n      getReportFileName(opts?.testId || this.interface.interfaceType || 'web');\n  }\n\n  async getActionSpace(): Promise<DeviceAction[]> {\n    const commonAssertionAction = defineActionAssert();\n\n    return [...this.interface.actionSpace(), commonAssertionAction];\n  }\n\n  async getUIContext(action?: ServiceAction): Promise<UIContext> {\n    // Check VL model configuration when UI context is first needed\n    this.ensureVLModelWarning();\n\n    // If page context is frozen, return the frozen context for all actions\n    if (this.frozenUIContext) {\n      debug('Using frozen page context for action:', action);\n      return this.frozenUIContext;\n    }\n\n    // Get original context\n    let context: UIContext;\n    if (this.interface.getContext) {\n      debug('Using page.getContext for action:', action);\n      context = await this.interface.getContext();\n    } else {\n      debug('Using commonContextParser');\n      context = await commonContextParser(this.interface, {\n        uploadServerUrl: this.modelConfigManager.getUploadTestServerUrl(),\n      });\n    }\n\n    debug('will get screenshot scale');\n    const computedScreenshotScale = await this.getScreenshotScale(context);\n    debug('computedScreenshotScale', computedScreenshotScale);\n\n    if (computedScreenshotScale !== 1) {\n      const scaleForLog = Number.parseFloat(computedScreenshotScale.toFixed(4));\n      debug(\n        `Applying computed screenshot scale: ${scaleForLog} (resize to logical size)`,\n      );\n      const targetWidth = Math.round(context.size.width);\n      const targetHeight = Math.round(context.size.height);\n      debug(`Resizing screenshot to ${targetWidth}x${targetHeight}`);\n      context.screenshotBase64 = await resizeImgBase64(\n        context.screenshotBase64,\n        { width: targetWidth, height: targetHeight },\n      );\n    } else {\n      debug(`screenshot scale=${computedScreenshotScale}`);\n    }\n\n    return context;\n  }\n\n  async _snapshotContext(): Promise<UIContext> {\n    return await this.getUIContext('locate');\n  }\n\n  /**\n   * @deprecated Use {@link setAIActContext} instead.\n   */\n  async setAIActionContext(prompt: string) {\n    await this.setAIActContext(prompt);\n  }\n\n  async setAIActContext(prompt: string) {\n    if (this.aiActContext) {\n      console.warn(\n        'aiActContext is already set, and it is called again, will override the previous setting',\n      );\n    }\n    this.opts.aiActContext = prompt;\n    this.opts.aiActionContext = prompt;\n  }\n\n  resetDump() {\n    this.dump = {\n      sdkVersion: getVersion(),\n      groupName: this.opts.groupName!,\n      groupDescription: this.opts.groupDescription,\n      executions: [],\n      modelBriefs: [],\n    };\n    this.executionDumpIndexByRunner = new WeakMap<TaskRunner, number>();\n\n    return this.dump;\n  }\n\n  appendExecutionDump(execution: ExecutionDump, runner?: TaskRunner) {\n    const currentDump = this.dump;\n    if (runner) {\n      const existingIndex = this.executionDumpIndexByRunner.get(runner);\n      if (existingIndex !== undefined) {\n        currentDump.executions[existingIndex] = execution;\n        return;\n      }\n      currentDump.executions.push(execution);\n      this.executionDumpIndexByRunner.set(\n        runner,\n        currentDump.executions.length - 1,\n      );\n      return;\n    }\n    currentDump.executions.push(execution);\n  }\n\n  dumpDataString() {\n    // update dump info\n    this.dump.groupName = this.opts.groupName!;\n    this.dump.groupDescription = this.opts.groupDescription;\n    return stringifyDumpData(this.dump);\n  }\n\n  reportHTMLString() {\n    return reportHTMLContent(this.dumpDataString());\n  }\n\n  writeOutActionDumps() {\n    if (this.destroyed) {\n      throw new Error(\n        'PageAgent has been destroyed. Cannot update report file.',\n      );\n    }\n    const { generateReport, autoPrintReportMsg } = this.opts;\n    this.reportFile = writeLogFile({\n      fileName: this.reportFileName!,\n      fileExt: groupedActionDumpFileExt,\n      fileContent: this.dumpDataString(),\n      type: 'dump',\n      generateReport,\n    });\n    debug('writeOutActionDumps', this.reportFile);\n    if (generateReport && autoPrintReportMsg && this.reportFile) {\n      printReportMsg(this.reportFile);\n    }\n  }\n\n  private async callbackOnTaskStartTip(task: ExecutionTask) {\n    const param = paramStr(task);\n    const tip = param ? `${typeStr(task)} - ${param}` : typeStr(task);\n\n    if (this.onTaskStartTip) {\n      await this.onTaskStartTip(tip);\n    }\n  }\n\n  wrapActionInActionSpace<T extends DeviceAction>(\n    name: string,\n  ): (param: ActionParam<T>) => Promise<ActionReturn<T>> {\n    return async (param: ActionParam<T>) => {\n      return await this.callActionInActionSpace<ActionReturn<T>>(name, param);\n    };\n  }\n\n  async callActionInActionSpace<T = any>(\n    type: string,\n    opt?: T, // and all other action params\n  ) {\n    debug('callActionInActionSpace', type, ',', opt);\n\n    const actionPlan: PlanningAction<T> = {\n      type: type as any,\n      param: (opt as any) || {},\n      thought: '',\n    };\n    debug('actionPlan', actionPlan); // , ', in which the locateParam is', locateParam);\n\n    const plans: PlanningAction[] = [actionPlan].filter(\n      Boolean,\n    ) as PlanningAction[];\n\n    const title = taskTitleStr(\n      type as any,\n      locateParamStr((opt as any)?.locate || {}),\n    );\n\n    // assume all operation in action space is related to locating\n    const defaultIntentModelConfig =\n      this.modelConfigManager.getModelConfig('default');\n    const modelConfigForPlanning =\n      this.modelConfigManager.getModelConfig('planning');\n\n    const { output } = await this.taskExecutor.runPlans(\n      title,\n      plans,\n      modelConfigForPlanning,\n      defaultIntentModelConfig,\n    );\n    return output;\n  }\n\n  async aiTap(locatePrompt: TUserPrompt, opt?: LocateOption) {\n    assert(locatePrompt, 'missing locate prompt for tap');\n\n    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);\n\n    return this.callActionInActionSpace('Tap', {\n      locate: detailedLocateParam,\n    });\n  }\n\n  async aiRightClick(locatePrompt: TUserPrompt, opt?: LocateOption) {\n    assert(locatePrompt, 'missing locate prompt for right click');\n\n    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);\n\n    return this.callActionInActionSpace('RightClick', {\n      locate: detailedLocateParam,\n    });\n  }\n\n  async aiDoubleClick(locatePrompt: TUserPrompt, opt?: LocateOption) {\n    assert(locatePrompt, 'missing locate prompt for double click');\n\n    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);\n\n    return this.callActionInActionSpace('DoubleClick', {\n      locate: detailedLocateParam,\n    });\n  }\n\n  async aiHover(locatePrompt: TUserPrompt, opt?: LocateOption) {\n    assert(locatePrompt, 'missing locate prompt for hover');\n\n    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);\n\n    return this.callActionInActionSpace('Hover', {\n      locate: detailedLocateParam,\n    });\n  }\n\n  // New signature, always use locatePrompt as the first param\n  async aiInput(\n    locatePrompt: TUserPrompt,\n    opt: LocateOption & { value: string | number } & {\n      autoDismissKeyboard?: boolean;\n    } & { mode?: 'replace' | 'clear' | 'append' },\n  ): Promise<any>;\n\n  // Legacy signature - deprecated\n  /**\n   * @deprecated Use aiInput(locatePrompt, opt) instead where opt contains the value\n   */\n  async aiInput(\n    value: string | number,\n    locatePrompt: TUserPrompt,\n    opt?: LocateOption & { autoDismissKeyboard?: boolean } & {\n      mode?: 'replace' | 'clear' | 'append';\n    }, // AndroidDeviceInputOpt &\n  ): Promise<any>;\n\n  // Implementation\n  async aiInput(\n    locatePromptOrValue: TUserPrompt | string | number,\n    locatePromptOrOpt:\n      | TUserPrompt\n      | (LocateOption & { value: string | number } & {\n          autoDismissKeyboard?: boolean;\n        } & { mode?: 'replace' | 'clear' | 'append' }) // AndroidDeviceInputOpt &\n      | undefined,\n    optOrUndefined?: LocateOption, // AndroidDeviceInputOpt &\n  ) {\n    let value: string | number;\n    let locatePrompt: TUserPrompt;\n    let opt:\n      | (LocateOption & { value: string | number } & {\n          autoDismissKeyboard?: boolean;\n        } & { mode?: 'replace' | 'clear' | 'append' }) // AndroidDeviceInputOpt &\n      | undefined;\n\n    // Check if using new signature (first param is locatePrompt, second has value)\n    if (\n      typeof locatePromptOrOpt === 'object' &&\n      locatePromptOrOpt !== null &&\n      'value' in locatePromptOrOpt\n    ) {\n      // New signature: aiInput(locatePrompt, opt)\n      locatePrompt = locatePromptOrValue as TUserPrompt;\n      const optWithValue = locatePromptOrOpt as LocateOption & {\n        // AndroidDeviceInputOpt &\n        value: string | number;\n        autoDismissKeyboard?: boolean;\n      };\n      value = optWithValue.value;\n      opt = optWithValue;\n    } else {\n      // Legacy signature: aiInput(value, locatePrompt, opt)\n      value = locatePromptOrValue as string | number;\n      locatePrompt = locatePromptOrOpt as TUserPrompt;\n      opt = {\n        ...optOrUndefined,\n        value,\n      };\n    }\n\n    assert(\n      typeof value === 'string' || typeof value === 'number',\n      'input value must be a string or number, use empty string if you want to clear the input',\n    );\n    assert(locatePrompt, 'missing locate prompt for input');\n\n    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);\n\n    // Convert value to string to ensure consistency\n    const stringValue = typeof value === 'number' ? String(value) : value;\n\n    return this.callActionInActionSpace('Input', {\n      ...(opt || {}),\n      value: stringValue,\n      locate: detailedLocateParam,\n    });\n  }\n\n  // New signature\n  async aiKeyboardPress(\n    locatePrompt: TUserPrompt,\n    opt: LocateOption & { keyName: string },\n  ): Promise<any>;\n\n  // Legacy signature - deprecated\n  /**\n   * @deprecated Use aiKeyboardPress(locatePrompt, opt) instead where opt contains the keyName\n   */\n  async aiKeyboardPress(\n    keyName: string,\n    locatePrompt?: TUserPrompt,\n    opt?: LocateOption,\n  ): Promise<any>;\n\n  // Implementation\n  async aiKeyboardPress(\n    locatePromptOrKeyName: TUserPrompt | string,\n    locatePromptOrOpt:\n      | TUserPrompt\n      | (LocateOption & { keyName: string })\n      | undefined,\n    optOrUndefined?: LocateOption,\n  ) {\n    let keyName: string;\n    let locatePrompt: TUserPrompt | undefined;\n    let opt: (LocateOption & { keyName: string }) | undefined;\n\n    // Check if using new signature (first param is locatePrompt, second has keyName)\n    if (\n      typeof locatePromptOrOpt === 'object' &&\n      locatePromptOrOpt !== null &&\n      'keyName' in locatePromptOrOpt\n    ) {\n      // New signature: aiKeyboardPress(locatePrompt, opt)\n      locatePrompt = locatePromptOrKeyName as TUserPrompt;\n      opt = locatePromptOrOpt as LocateOption & {\n        keyName: string;\n      };\n    } else {\n      // Legacy signature: aiKeyboardPress(keyName, locatePrompt, opt)\n      keyName = locatePromptOrKeyName as string;\n      locatePrompt = locatePromptOrOpt as TUserPrompt | undefined;\n      opt = {\n        ...(optOrUndefined || {}),\n        keyName,\n      };\n    }\n\n    assert(opt?.keyName, 'missing keyName for keyboard press');\n\n    const detailedLocateParam = locatePrompt\n      ? buildDetailedLocateParam(locatePrompt, opt)\n      : undefined;\n\n    return this.callActionInActionSpace('KeyboardPress', {\n      ...(opt || {}),\n      locate: detailedLocateParam,\n    });\n  }\n\n  // New signature\n  async aiScroll(\n    locatePrompt: TUserPrompt | undefined,\n    opt: LocateOption & ScrollParam,\n  ): Promise<any>;\n\n  // Legacy signature - deprecated\n  /**\n   * @deprecated Use aiScroll(locatePrompt, opt) instead where opt contains the scroll parameters\n   */\n  async aiScroll(\n    scrollParam: ScrollParam,\n    locatePrompt?: TUserPrompt,\n    opt?: LocateOption,\n  ): Promise<any>;\n\n  // Implementation\n  async aiScroll(\n    locatePromptOrScrollParam: TUserPrompt | ScrollParam | undefined,\n    locatePromptOrOpt: TUserPrompt | (LocateOption & ScrollParam) | undefined,\n    optOrUndefined?: LocateOption,\n  ) {\n    let scrollParam: ScrollParam;\n    let locatePrompt: TUserPrompt | undefined;\n    let opt: LocateOption | undefined;\n\n    // Check if using new signature (first param is locatePrompt, second has scroll params)\n    if (\n      typeof locatePromptOrOpt === 'object' &&\n      ('direction' in locatePromptOrOpt ||\n        'scrollType' in locatePromptOrOpt ||\n        'distance' in locatePromptOrOpt)\n    ) {\n      // New signature: aiScroll(locatePrompt, opt)\n      locatePrompt = locatePromptOrScrollParam as TUserPrompt;\n      opt = locatePromptOrOpt as LocateOption & ScrollParam;\n    } else {\n      // Legacy signature: aiScroll(scrollParam, locatePrompt, opt)\n      scrollParam = locatePromptOrScrollParam as ScrollParam;\n      locatePrompt = locatePromptOrOpt as TUserPrompt | undefined;\n      opt = {\n        ...(optOrUndefined || {}),\n        ...(scrollParam || {}),\n      };\n    }\n\n    if (opt) {\n      const normalizedScrollType = normalizeScrollType(\n        (opt as ScrollParam).scrollType as\n          | ScrollParam['scrollType']\n          | LegacyScrollType\n          | undefined,\n      );\n\n      if (normalizedScrollType !== (opt as ScrollParam).scrollType) {\n        (opt as ScrollParam) = {\n          ...(opt || {}),\n          scrollType: normalizedScrollType as ScrollParam['scrollType'],\n        };\n      }\n    }\n\n    const detailedLocateParam = buildDetailedLocateParam(\n      locatePrompt || '',\n      opt,\n    );\n\n    return this.callActionInActionSpace('Scroll', {\n      ...(opt || {}),\n      locate: detailedLocateParam,\n    });\n  }\n\n  async aiAct(taskPrompt: string, opt?: AiActOptions) {\n    const modelConfigForPlanning =\n      this.modelConfigManager.getModelConfig('planning');\n    const defaultIntentModelConfig =\n      this.modelConfigManager.getModelConfig('default');\n\n    const includeBboxInPlanning =\n      modelConfigForPlanning.modelName === defaultIntentModelConfig.modelName &&\n      modelConfigForPlanning.openaiBaseURL ===\n        defaultIntentModelConfig.openaiBaseURL;\n    debug('setting includeBboxInPlanning to', includeBboxInPlanning);\n\n    const cacheable = opt?.cacheable;\n    const replanningCycleLimit = this.resolveReplanningCycleLimit(\n      modelConfigForPlanning,\n    );\n    // if vlm-ui-tars, plan cache is not used\n    const isVlmUiTars = modelConfigForPlanning.vlMode === 'vlm-ui-tars';\n    const matchedCache =\n      isVlmUiTars || cacheable === false\n        ? undefined\n        : this.taskCache?.matchPlanCache(taskPrompt);\n    if (\n      matchedCache &&\n      this.taskCache?.isCacheResultUsed &&\n      matchedCache.cacheContent?.yamlWorkflow?.trim()\n    ) {\n      // log into report file\n      await this.taskExecutor.loadYamlFlowAsPlanning(\n        taskPrompt,\n        matchedCache.cacheContent.yamlWorkflow,\n      );\n\n      debug('matched cache, will call .runYaml to run the action');\n      const yaml = matchedCache.cacheContent.yamlWorkflow;\n      return this.runYaml(yaml);\n    }\n\n    // If cache matched but yamlWorkflow is empty, fall through to normal execution\n\n    const useDeepThink = (this.opts as any)?._deepThink;\n    if (useDeepThink) {\n      debug('using deep think planning settings');\n    }\n    const imagesIncludeCount: number | undefined = useDeepThink ? undefined : 2;\n    const { output } = await this.taskExecutor.action(\n      taskPrompt,\n      modelConfigForPlanning,\n      defaultIntentModelConfig,\n      includeBboxInPlanning,\n      this.aiActContext,\n      cacheable,\n      replanningCycleLimit,\n      imagesIncludeCount,\n    );\n\n    // update cache\n    if (this.taskCache && output?.yamlFlow && cacheable !== false) {\n      const yamlContent: MidsceneYamlScript = {\n        tasks: [\n          {\n            name: taskPrompt,\n            flow: output.yamlFlow,\n          },\n        ],\n      };\n      const yamlFlowStr = yaml.dump(yamlContent);\n      this.taskCache.updateOrAppendCacheRecord(\n        {\n          type: 'plan',\n          prompt: taskPrompt,\n          yamlWorkflow: yamlFlowStr,\n        },\n        matchedCache,\n      );\n    }\n\n    return output;\n  }\n\n  /**\n   * @deprecated Use {@link Agent.aiAct} instead.\n   */\n  async aiAction(taskPrompt: string, opt?: AiActOptions) {\n    return this.aiAct(taskPrompt, opt);\n  }\n\n  async aiQuery<ReturnType = any>(\n    demand: ServiceExtractParam,\n    opt: ServiceExtractOption = defaultServiceExtractOption,\n  ): Promise<ReturnType> {\n    const modelConfig = this.modelConfigManager.getModelConfig('insight');\n    const { output } = await this.taskExecutor.createTypeQueryExecution(\n      'Query',\n      demand,\n      modelConfig,\n      opt,\n    );\n    return output as ReturnType;\n  }\n\n  async aiBoolean(\n    prompt: TUserPrompt,\n    opt: ServiceExtractOption = defaultServiceExtractOption,\n  ): Promise<boolean> {\n    const modelConfig = this.modelConfigManager.getModelConfig('insight');\n\n    const { textPrompt, multimodalPrompt } = parsePrompt(prompt);\n    const { output } = await this.taskExecutor.createTypeQueryExecution(\n      'Boolean',\n      textPrompt,\n      modelConfig,\n      opt,\n      multimodalPrompt,\n    );\n    return output as boolean;\n  }\n\n  async aiNumber(\n    prompt: TUserPrompt,\n    opt: ServiceExtractOption = defaultServiceExtractOption,\n  ): Promise<number> {\n    const modelConfig = this.modelConfigManager.getModelConfig('insight');\n\n    const { textPrompt, multimodalPrompt } = parsePrompt(prompt);\n    const { output } = await this.taskExecutor.createTypeQueryExecution(\n      'Number',\n      textPrompt,\n      modelConfig,\n      opt,\n      multimodalPrompt,\n    );\n    return output as number;\n  }\n\n  async aiString(\n    prompt: TUserPrompt,\n    opt: ServiceExtractOption = defaultServiceExtractOption,\n  ): Promise<string> {\n    const modelConfig = this.modelConfigManager.getModelConfig('insight');\n\n    const { textPrompt, multimodalPrompt } = parsePrompt(prompt);\n    const { output } = await this.taskExecutor.createTypeQueryExecution(\n      'String',\n      textPrompt,\n      modelConfig,\n      opt,\n      multimodalPrompt,\n    );\n    return output as string;\n  }\n\n  async aiAsk(\n    prompt: TUserPrompt,\n    opt: ServiceExtractOption = defaultServiceExtractOption,\n  ): Promise<string> {\n    return this.aiString(prompt, opt);\n  }\n\n  async describeElementAtPoint(\n    center: [number, number],\n    opt?: {\n      verifyPrompt?: boolean;\n      retryLimit?: number;\n      deepThink?: boolean;\n    } & LocatorValidatorOption,\n  ): Promise<AgentDescribeElementAtPointResult> {\n    const { verifyPrompt = true, retryLimit = 3 } = opt || {};\n\n    let success = false;\n    let retryCount = 0;\n    let resultPrompt = '';\n    let deepThink = opt?.deepThink || false;\n    let verifyResult: LocateValidatorResult | undefined;\n\n    while (!success && retryCount < retryLimit) {\n      if (retryCount >= 2) {\n        deepThink = true;\n      }\n      debug(\n        'aiDescribe',\n        center,\n        'verifyPrompt',\n        verifyPrompt,\n        'retryCount',\n        retryCount,\n        'deepThink',\n        deepThink,\n      );\n      // use same intent as aiLocate\n      const modelConfig = this.modelConfigManager.getModelConfig('insight');\n\n      const text = await this.service.describe(center, modelConfig, {\n        deepThink,\n      });\n      debug('aiDescribe text', text);\n      assert(text.description, `failed to describe element at [${center}]`);\n      resultPrompt = text.description;\n\n      verifyResult = await this.verifyLocator(\n        resultPrompt,\n        deepThink ? { deepThink: true } : undefined,\n        center,\n        opt,\n      );\n      if (verifyResult.pass) {\n        success = true;\n      } else {\n        retryCount++;\n      }\n    }\n\n    return {\n      prompt: resultPrompt,\n      deepThink,\n      verifyResult,\n    };\n  }\n\n  async verifyLocator(\n    prompt: string,\n    locateOpt: LocateOption | undefined,\n    expectCenter: [number, number],\n    verifyLocateOption?: LocatorValidatorOption,\n  ): Promise<LocateValidatorResult> {\n    debug('verifyLocator', prompt, locateOpt, expectCenter, verifyLocateOption);\n\n    const { center: verifyCenter, rect: verifyRect } = await this.aiLocate(\n      prompt,\n      locateOpt,\n    );\n    const distance = distanceOfTwoPoints(expectCenter, verifyCenter);\n    const included = includedInRect(expectCenter, verifyRect);\n    const pass =\n      distance <= (verifyLocateOption?.centerDistanceThreshold || 20) ||\n      included;\n    const verifyResult = {\n      pass,\n      rect: verifyRect,\n      center: verifyCenter,\n      centerDistance: distance,\n    };\n    debug('aiDescribe verifyResult', verifyResult);\n    return verifyResult;\n  }\n\n  async aiLocate(prompt: TUserPrompt, opt?: LocateOption) {\n    const locateParam = buildDetailedLocateParam(prompt, opt);\n    assert(locateParam, 'cannot get locate param for aiLocate');\n    const locatePlan = locatePlanForLocate(locateParam);\n    const plans = [locatePlan];\n    const defaultIntentModelConfig =\n      this.modelConfigManager.getModelConfig('default');\n    const modelConfigForPlanning =\n      this.modelConfigManager.getModelConfig('planning');\n\n    const { output } = await this.taskExecutor.runPlans(\n      taskTitleStr('Locate', locateParamStr(locateParam)),\n      plans,\n      modelConfigForPlanning,\n      defaultIntentModelConfig,\n    );\n\n    const { element } = output;\n\n    const dprValue = await (this.interface.size() as any).dpr;\n    const dprEntry = dprValue\n      ? {\n          dpr: dprValue,\n        }\n      : {};\n    return {\n      rect: element?.rect,\n      center: element?.center,\n      ...dprEntry,\n    } as Pick<LocateResultElement, 'rect' | 'center'> & {\n      dpr?: number; // this field is deprecated\n    };\n  }\n\n  async aiAssert(\n    assertion: TUserPrompt,\n    msg?: string,\n    opt?: AgentAssertOpt & ServiceExtractOption,\n  ) {\n    const modelConfig = this.modelConfigManager.getModelConfig('insight');\n\n    const serviceOpt: ServiceExtractOption = {\n      domIncluded: opt?.domIncluded ?? defaultServiceExtractOption.domIncluded,\n      screenshotIncluded:\n        opt?.screenshotIncluded ??\n        defaultServiceExtractOption.screenshotIncluded,\n    };\n\n    const { textPrompt, multimodalPrompt } = parsePrompt(assertion);\n    const assertionText =\n      typeof assertion === 'string' ? assertion : assertion.prompt;\n\n    try {\n      const { output, thought } =\n        await this.taskExecutor.createTypeQueryExecution<boolean>(\n          'Assert',\n          textPrompt,\n          modelConfig,\n          serviceOpt,\n          multimodalPrompt,\n        );\n\n      const pass = Boolean(output);\n      const message = pass\n        ? undefined\n        : `Assertion failed: ${msg || assertionText}\\nReason: ${thought || '(no_reason)'}`;\n\n      if (opt?.keepRawResponse) {\n        return {\n          pass,\n          thought,\n          message,\n        };\n      }\n\n      if (!pass) {\n        throw new Error(message);\n      }\n    } catch (error) {\n      if (error instanceof TaskExecutionError) {\n        const errorTask = error.errorTask;\n        const thought = errorTask?.thought;\n        const rawError = errorTask?.error;\n        const rawMessage =\n          errorTask?.errorMessage ||\n          (rawError instanceof Error\n            ? rawError.message\n            : rawError\n              ? String(rawError)\n              : undefined);\n        const reason = thought || rawMessage || '(no_reason)';\n        const message = `Assertion failed: ${msg || assertionText}\\nReason: ${reason}`;\n\n        if (opt?.keepRawResponse) {\n          return {\n            pass: false,\n            thought,\n            message,\n          };\n        }\n\n        throw new Error(message, {\n          cause: rawError ?? error,\n        });\n      }\n\n      throw error;\n    }\n  }\n\n  async aiWaitFor(assertion: TUserPrompt, opt?: AgentWaitForOpt) {\n    const modelConfig = this.modelConfigManager.getModelConfig('insight');\n    await this.taskExecutor.waitFor(\n      assertion,\n      {\n        timeoutMs: opt?.timeoutMs || 15 * 1000,\n        checkIntervalMs: opt?.checkIntervalMs || 3 * 1000,\n      },\n      modelConfig,\n    );\n  }\n\n  async ai(...args: Parameters<typeof this.aiAct>) {\n    return this.aiAct(...args);\n  }\n\n  async runYaml(yamlScriptContent: string): Promise<{\n    result: Record<string, any>;\n  }> {\n    const script = parseYamlScript(yamlScriptContent, 'yaml');\n    const player = new ScriptPlayer(script, async () => {\n      return { agent: this, freeFn: [] };\n    });\n    await player.run();\n\n    if (player.status === 'error') {\n      const errors = player.taskStatusList\n        .filter((task) => task.status === 'error')\n        .map((task) => {\n          return `task - ${task.name}: ${task.error?.message}`;\n        })\n        .join('\\n');\n      throw new Error(`Error(s) occurred in running yaml script:\\n${errors}`);\n    }\n\n    return {\n      result: player.result,\n    };\n  }\n\n  async evaluateJavaScript(script: string) {\n    assert(\n      this.interface.evaluateJavaScript,\n      'evaluateJavaScript is not supported in current agent',\n    );\n    return this.interface.evaluateJavaScript(script);\n  }\n\n  /**\n   * Add a dump update listener\n   * @param listener Listener function\n   * @returns A remove function that can be called to remove this listener\n   */\n  addDumpUpdateListener(\n    listener: (dump: string, executionDump?: ExecutionDump) => void,\n  ): () => void {\n    this.dumpUpdateListeners.push(listener);\n\n    // Return remove function\n    return () => {\n      this.removeDumpUpdateListener(listener);\n    };\n  }\n\n  /**\n   * Remove a dump update listener\n   * @param listener The listener function to remove\n   */\n  removeDumpUpdateListener(\n    listener: (dump: string, executionDump?: ExecutionDump) => void,\n  ): void {\n    const index = this.dumpUpdateListeners.indexOf(listener);\n    if (index > -1) {\n      this.dumpUpdateListeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Clear all dump update listeners\n   */\n  clearDumpUpdateListeners(): void {\n    this.dumpUpdateListeners = [];\n  }\n\n  async destroy() {\n    // Early return if already destroyed\n    if (this.destroyed) {\n      return;\n    }\n\n    await this.interface.destroy?.();\n    this.resetDump(); // reset dump to release memory\n    this.destroyed = true;\n  }\n\n  async recordToReport(\n    title?: string,\n    opt?: {\n      content: string;\n    },\n  ) {\n    // 1. screenshot\n    const base64 = await this.interface.screenshotBase64();\n    const now = Date.now();\n    // 2. build recorder\n    const recorder: ExecutionRecorderItem[] = [\n      {\n        type: 'screenshot',\n        ts: now,\n        screenshot: base64,\n      },\n    ];\n    // 3. build ExecutionTaskLog\n    const task: ExecutionTaskLog = {\n      type: 'Log',\n      subType: 'Screenshot',\n      status: 'finished',\n      recorder,\n      timing: {\n        start: now,\n        end: now,\n        cost: 0,\n      },\n      param: {\n        content: opt?.content || '',\n      },\n      executor: async () => {},\n    };\n    // 4. build ExecutionDump\n    const executionDump: ExecutionDump = {\n      logTime: now,\n      name: `Log - ${title || 'untitled'}`,\n      description: opt?.content || '',\n      tasks: [task],\n    };\n    // 5. append to execution dump\n    this.appendExecutionDump(executionDump);\n\n    // Call all registered dump update listeners\n    const dumpString = this.dumpDataString();\n    for (const listener of this.dumpUpdateListeners) {\n      try {\n        listener(dumpString);\n      } catch (error) {\n        console.error('Error in onDumpUpdate listener', error);\n      }\n    }\n\n    this.writeOutActionDumps();\n  }\n\n  /**\n   * @deprecated Use {@link Agent.recordToReport} instead.\n   */\n  async logScreenshot(\n    title?: string,\n    opt?: {\n      content: string;\n    },\n  ) {\n    await this.recordToReport(title, opt);\n  }\n\n  _unstableLogContent() {\n    const { groupName, groupDescription, executions } = this.dump;\n    return {\n      groupName,\n      groupDescription,\n      executions: executions || [],\n    };\n  }\n\n  /**\n   * Freezes the current page context to be reused in subsequent AI operations\n   * This avoids recalculating page context for each operation\n   */\n  async freezePageContext(): Promise<void> {\n    debug('Freezing page context');\n    const context = await this._snapshotContext();\n    // Mark the context as frozen\n    context._isFrozen = true;\n    this.frozenUIContext = context;\n    debug('Page context frozen successfully');\n  }\n\n  /**\n   * Unfreezes the page context, allowing AI operations to calculate context dynamically\n   */\n  async unfreezePageContext(): Promise<void> {\n    debug('Unfreezing page context');\n    this.frozenUIContext = undefined;\n    debug('Page context unfrozen successfully');\n  }\n\n  /**\n   * Process cache configuration and return normalized cache settings\n   */\n  private processCacheConfig(opts: AgentOpt): {\n    id: string;\n    enabled: boolean;\n    readOnly: boolean;\n    writeOnly: boolean;\n  } | null {\n    // Validate original cache config before processing\n    // Agent requires explicit IDs - don't allow auto-generation\n    if (opts.cache === true) {\n      throw new Error(\n        'cache: true requires an explicit cache ID. Please provide:\\n' +\n          'Example: cache: { id: \"my-cache-id\" }',\n      );\n    }\n\n    // Check if cache config object is missing ID\n    if (\n      opts.cache &&\n      typeof opts.cache === 'object' &&\n      opts.cache !== null &&\n      !opts.cache.id\n    ) {\n      throw new Error(\n        'cache configuration requires an explicit id.\\n' +\n          'Example: cache: { id: \"my-cache-id\" }',\n      );\n    }\n\n    // Use the unified utils function to process cache configuration\n    const cacheConfig = processCacheConfig(\n      opts.cache,\n      opts.cacheId || opts.testId || 'default',\n    );\n\n    if (!cacheConfig) {\n      return null;\n    }\n\n    // Handle cache configuration object\n    if (typeof cacheConfig === 'object' && cacheConfig !== null) {\n      const id = cacheConfig.id;\n      const rawStrategy = cacheConfig.strategy as unknown;\n      let strategyValue: string;\n\n      if (rawStrategy === undefined) {\n        strategyValue = 'read-write';\n      } else if (typeof rawStrategy === 'string') {\n        strategyValue = rawStrategy;\n      } else {\n        throw new Error(\n          `cache.strategy must be a string when provided, but received type ${typeof rawStrategy}`,\n        );\n      }\n\n      if (!isValidCacheStrategy(strategyValue)) {\n        throw new Error(\n          `cache.strategy must be one of ${CACHE_STRATEGY_VALUES}, but received \"${strategyValue}\"`,\n        );\n      }\n\n      const isReadOnly = strategyValue === 'read-only';\n      const isWriteOnly = strategyValue === 'write-only';\n\n      return {\n        id,\n        enabled: !isWriteOnly,\n        readOnly: isReadOnly,\n        writeOnly: isWriteOnly,\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Manually flush cache to file\n   * @param options - Optional configuration\n   * @param options.cleanUnused - If true, removes unused cache records before flushing\n   */\n  async flushCache(options?: { cleanUnused?: boolean }): Promise<void> {\n    if (!this.taskCache) {\n      throw new Error('Cache is not configured');\n    }\n\n    this.taskCache.flushCacheToFile(options);\n  }\n}\n\nexport const createAgent = (\n  interfaceInstance: AbstractInterface,\n  opts?: AgentOpt,\n) => {\n  return new Agent(interfaceInstance, opts);\n};\n"],"names":["__webpack_require__","module","getter","definition","key","Object","obj","prop","Symbol","debug","getDebug","distanceOfTwoPoints","p1","p2","x1","y1","x2","y2","Math","includedInRect","point","rect","x","y","left","top","width","height","defaultServiceExtractOption","CACHE_STRATEGIES","isValidCacheStrategy","strategy","value","CACHE_STRATEGY_VALUES","legacyScrollTypeMap","normalizeScrollType","scrollType","defaultReplanningCycleLimit","defaultVlmUiTarsReplanningCycleLimit","Agent","callback","context","undefined","pageWidth","assert","screenshotWidth","imageInfoOfBase64","Number","computedScale","modelConfigForPlanning","commonAssertionAction","defineActionAssert","action","commonContextParser","computedScreenshotScale","scaleForLog","targetWidth","targetHeight","resizeImgBase64","prompt","console","getVersion","WeakMap","execution","runner","currentDump","existingIndex","stringifyDumpData","reportHTMLContent","Error","generateReport","autoPrintReportMsg","writeLogFile","groupedActionDumpFileExt","printReportMsg","task","param","paramStr","tip","typeStr","name","type","opt","actionPlan","plans","Boolean","title","taskTitleStr","locateParamStr","defaultIntentModelConfig","output","locatePrompt","detailedLocateParam","buildDetailedLocateParam","locatePromptOrValue","locatePromptOrOpt","optOrUndefined","optWithValue","stringValue","String","locatePromptOrKeyName","keyName","locatePromptOrScrollParam","scrollParam","normalizedScrollType","taskPrompt","includeBboxInPlanning","cacheable","replanningCycleLimit","isVlmUiTars","matchedCache","yaml","useDeepThink","imagesIncludeCount","yamlContent","yamlFlowStr","demand","modelConfig","textPrompt","multimodalPrompt","parsePrompt","center","verifyPrompt","retryLimit","success","retryCount","resultPrompt","deepThink","verifyResult","text","locateOpt","expectCenter","verifyLocateOption","verifyCenter","verifyRect","distance","included","pass","locateParam","locatePlan","locatePlanForLocate","element","dprValue","dprEntry","assertion","msg","serviceOpt","assertionText","thought","message","error","TaskExecutionError","errorTask","rawError","rawMessage","reason","args","yamlScriptContent","script","parseYamlScript","player","ScriptPlayer","errors","listener","index","base64","now","Date","recorder","executionDump","dumpString","groupName","groupDescription","executions","opts","cacheConfig","processCacheConfig","id","rawStrategy","strategyValue","isReadOnly","isWriteOnly","options","interfaceInstance","envConfig","globalConfigManager","envReplanningCycleLimitRaw","MIDSCENE_REPLANNING_CYCLE_LIMIT","envReplanningCycleLimit","resolvedAiActContext","Array","hasCustomConfig","ModelConfigManager","globalModelConfigManager","Service","cacheConfigObj","TaskCache","baseActionSpace","fullActionSpace","TaskExecutor","getReportFileName","createAgent"],"mappings":"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"}