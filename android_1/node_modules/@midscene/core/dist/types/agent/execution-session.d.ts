import { type TaskExecutionError, TaskRunner } from '../task-runner';
import type { ExecutionTaskApply, ExecutionTaskProgressOptions, UIContext } from '../types';
type ExecutionSessionOptions = ExecutionTaskProgressOptions & {
    tasks?: ExecutionTaskApply[];
    onTaskUpdate?: (runner: TaskRunner, error?: TaskExecutionError) => Promise<void> | void;
};
/**
 * Thin wrapper around {@link TaskRunner} that represents a single linear execution run.
 */
export declare class ExecutionSession {
    private readonly runner;
    constructor(name: string, contextProvider: () => Promise<UIContext>, options?: ExecutionSessionOptions);
    append(tasks: ExecutionTaskApply[] | ExecutionTaskApply, options?: {
        allowWhenError?: boolean;
    }): Promise<void>;
    appendAndRun(tasks: ExecutionTaskApply[] | ExecutionTaskApply, options?: {
        allowWhenError?: boolean;
    }): Promise<{
        output: any;
        thought?: string;
    } | undefined>;
    run(options?: {
        allowWhenError?: boolean;
    }): Promise<{
        output: any;
        thought?: string;
    } | undefined>;
    isInErrorState(): boolean;
    latestErrorTask(): import("../types").ExecutionTask | null;
    appendErrorPlan(errorMsg: string): Promise<{
        output: undefined;
        runner: TaskRunner;
    }>;
    getRunner(): TaskRunner;
}
export {};
