"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    BaseMidsceneTools: ()=>BaseMidsceneTools
});
const img_namespaceObject = require("@midscene/shared/img");
const logger_namespaceObject = require("@midscene/shared/logger");
const external_tool_generator_js_namespaceObject = require("./tool-generator.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const debug = (0, logger_namespaceObject.getDebug)('mcp:base-tools');
class BaseMidsceneTools {
    preparePlatformTools() {
        return [];
    }
    async initTools() {
        this.toolDefinitions = [];
        const platformTools = this.preparePlatformTools();
        this.toolDefinitions.push(...platformTools);
        let actionSpace;
        try {
            const agent = await this.ensureAgent();
            actionSpace = await agent.getActionSpace();
            debug('Action space from connected agent:', actionSpace.map((a)=>a.name).join(', '));
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            errorMessage.includes('requires a URL') || errorMessage.includes('web_connect') ? debug('Bridge mode detected - agent will be initialized on first web_connect call') : debug('Agent not available yet, using temporary device for action space');
            const tempDevice = this.createTemporaryDevice();
            actionSpace = tempDevice.actionSpace();
            debug('Action space from temporary device:', actionSpace.map((a)=>a.name).join(', '));
            await tempDevice.destroy?.();
        }
        const actionTools = (0, external_tool_generator_js_namespaceObject.generateToolsFromActionSpace)(actionSpace, ()=>this.ensureAgent());
        const commonTools = (0, external_tool_generator_js_namespaceObject.generateCommonTools)(()=>this.ensureAgent());
        this.toolDefinitions.push(...actionTools, ...commonTools);
        debug('Total tools prepared:', this.toolDefinitions.length);
    }
    attachToServer(server) {
        this.mcpServer = server;
        if (0 === this.toolDefinitions.length) debug('Warning: No tools to register. Tools may be initialized lazily.');
        for (const toolDef of this.toolDefinitions)if (toolDef.autoDestroy) this.toolWithAutoDestroy(toolDef.name, toolDef.description, toolDef.schema, toolDef.handler);
        else this.mcpServer.tool(toolDef.name, toolDef.description, toolDef.schema, toolDef.handler);
        debug('Registered', this.toolDefinitions.length, 'tools');
    }
    toolWithAutoDestroy(name, description, schema, handler) {
        if (!this.mcpServer) throw new Error('MCP server not attached');
        this.mcpServer.tool(name, description, schema, async (...args)=>{
            try {
                return await handler(...args);
            } finally{
                if (!process.env.MIDSCENE_MCP_DISABLE_AGENT_AUTO_DESTROY) {
                    try {
                        await this.agent?.destroy?.();
                    } catch (error) {
                        debug('Failed to destroy agent during cleanup:', error);
                    }
                    this.agent = void 0;
                }
            }
        });
    }
    async closeBrowser() {
        await this.agent?.destroy?.();
    }
    buildScreenshotContent(screenshot) {
        const { mimeType, body } = (0, img_namespaceObject.parseBase64)(screenshot);
        return [
            {
                type: 'image',
                data: body,
                mimeType
            }
        ];
    }
    constructor(){
        _define_property(this, "mcpServer", void 0);
        _define_property(this, "agent", void 0);
        _define_property(this, "toolDefinitions", []);
    }
}
exports.BaseMidsceneTools = __webpack_exports__.BaseMidsceneTools;
for(var __rspack_i in __webpack_exports__)if (-1 === [
    "BaseMidsceneTools"
].indexOf(__rspack_i)) exports[__rspack_i] = __webpack_exports__[__rspack_i];
Object.defineProperty(exports, '__esModule', {
    value: true
});
